% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Striktheit und Fixpunktoperator}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\label{sec:striktheit-und-rekursion}

Bisher wurde eine Wahrheit größtenteils ignoriert: Die generierten freien Theoreme sind nur unter ganz bestimmten
Bedingungen gültig. Beim Beispiel \texttt{$f :: [a] \rightarrow [a]$} wurde behauptet, dass die Funktion \texttt{f}
lediglich Ausdrücke aus der Eingabeliste in der Ausgabeliste weiderverwenden könne. Tatsächlich entspricht das nicht ganz der
Wahrheit, denn in Haskell ist zum Beispiel auch denkbar, dass $\bot$ zurückgegeben wird, beispielsweise
durch Nichtterminierung oder einen Laufzeitfehler.

\textit{free-theorems} definiert verschiedene Untermengen der Programmiersprache Haskell, zu denen sich unterschiedlich komplexe
Theoreme generieren lassen. Ein Faktor, der nämlich Probleme bereiten kann, ist der Fixpunktoperator, ein anderer der
Striktheitsoperator.
Die Bilbiothek definiert drei Untermengen der Sprache Haskell:

\begin{itemize}
   \item BasicSubset
   \item SubsetWithFix
   \item SubsetWithSeq
\end{itemize}

Die erste Untermenge, BasicSubset, entspricht nach Böhme \cite{freetheorems} dem Girard-Reynoldschen Lambda-Kalkül, erweitert um Datentypen und
Typklassen. Insbesondere sind aber keine undefinierten Werte erlaubt, die zum Beispiel durch Nichtterminierung
oder Pattern-Matching-Fehler auftreten.
Das ändert sich in \texttt{SubsetWithFix}. Hier ist zusätzlich der Fixpunktoperator \textit{fix} verfügbar, und es müssen folglich undefinierte
Werte erlaubt werden. Was noch fehlt, ist die \texttt{seq}-Funktion sowie Striktheits-Flags.

Die Untermenge SubsetWithSeq ist die Sprache, die auch \texttt{seq} und Striktheitsannotationen enthält.
Es wird noch eine weitere Unterscheidung eingeführt: Zu \texttt{SubsetWithFix} und \texttt{SubsetWithSeq} kann noch unterschieden werden,
ob die Theoreme als Gleichungen oder als Ungleichungen erwünscht sind.

%In den folgenden Abschnitt sollen kurz die Probleme erläutert werden, die die jeweiligen Operatoren bezüglich freien Theoremen
%mit sich bringen sowie jeweils Möglichkeiten, diese Probleme durch entsprechende Einschränkungen der Relationen und
%Funktionen zu umgehen. Die Unterscheidung zwischen Gleichungen und Ungleichungen wird im Zusammenhang mit \texttt{seq}
%erläutert.

Im Folgenden soll kurz auf die Problematik eingegangen werden, die durch die Existenz dieser Operatoren entsteht. Es wird
skizziert, inwiefern man die konstruierten Relationen einschränken muss, damit die generierten freien Theoreme Gültigkeit
behalten.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Der Fixpunktoperator fix}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Die Funktion \texttt{fix} hat die folgende Signatur.

\begin{minted}{haskell}
fix :: (a -> a) -> a
\end{minted}

Auch die Auswirkungen von \texttt{fix} auf freie Theoreme werden von Wadler \cite{wadler} behandelt.
Der \texttt{fix}-Operator gibt den kleinsten Fixpunkt der übergebenen Funktion $f$
zurück, sprich: Das kleinste (am wenigsten definierte) $x$, für das gilt $f(x) = x$. Bei $x$ handelt es sich dabei
typischerweise selbst um eine Funktion, d.h. $f$ ist eine Funktion auf Funktionen.

Als Beispiel sei hier die Fakultätsfunktion \texttt{fak} gegeben, die wie folgt mithilfe des Fixpunktoperators definiert werden
kann.

\begin{minted}{haskell}
fak :: Int -> Int
fak = fix h
   where h :: (Int -> Int) -> (Int -> Int)
         h f = \x -> if x == 0 then 1
                               else x * f (x - 1)
\end{minted}

\texttt{fak} ist also definiert als der kleinste Fixpunkt der Funktion $h$, die eine beliebige Funktion $f$ abbildet auf
eine neue Funktion, die für $x = 0$ einfach $1$ zurückgibt und ansonsten die übergebene Funktion $f$ aufruft mit dem
Argument $x - 1$.
Der gesuchte Fixpunkt von $h$ ist folglich eine solche Funktion, die durch erneute Anwendung von $h$ nicht mehr
verändert wird.
%Natürlich ist eine solche Funktion im Endlichen nicht zu finden, doch das ist auch nicht notwendig, da
Haskell Lazy Evaluation für die Auswertung nutzt.

Letztlich ist $h$ also eine Funktion, die als Parameter eine Funktion übergeben bekommt, die den nächsten Rekursionsschritt
darstellt; der Fixpunktoperator ist somit die semantische Grundlage für Rekursion.
%Auch wenn man rekursive Funktionen in der gewohnten Schreibweise schreibt, so wird semantisch betrachtet der
%Fixpunktoperator verwendet.

Voigtländer \cite{voigtlander} argumentiert nun folgendermaßen: Rekursion hat zur Folge, dass polymorphe Funktionen
nun zusätzlich die Möglichkeit haben, eine Endlosrekursion und damit $\bot$ einzuführen. Wir kommen abermals zurück auf das
Beispiel $f :: [a] \rightarrow [a]$.
%Wie eingangs erwähnt hat dies also zur Folge, dass polymorphe Funktionen immer die zusätzliche Möglichkeit haben,
%eine Endlosrekursion und damit $\bot$ einzuführen. Wir kommen abermals zurück auf das Beispiel $f :: [a] \rightarrow [a]$.
Auch dieses $\bot$-Element kann nicht zufällig entstehen: Die Funktion ist in ihren Entscheidungen nach wie vor auf
die Listenlänge der Eingabeliste beschränkt, das heißt selbst wenn $\bot$ auftritt, wird es für zwei gleich lange Listen
$l$ und $l'$ immer an den gleichen Stellen auftreten.

Für eine beliebige Funktion $g$ auf dem konkreten Listentyp der Funktion $f$ heißt das für eine beliebige Liste $l$, dass die folgende
Aussage gilt, \textit{wenn} $g$ jedes $\bot$ wieder auf $\bot$ abbildet, sprich: strikt ist.

\begin{align*}
f\ (map\ g\ l) = map\ g\ (f\ l)
\end{align*}

%Mithilfe des Fixpunktoperators lässt sich also Rekursion darstellen.
%fix f = let x = f x in x


%Dabei macht die Funktion \texttt{fix} nichts anderes, als den kleinsten Fixpunkt der übergebenen Funktion zurückzugeben.

Dementsprechend müssen nach Wadler \cite{wadler} alle relationalen Interpretationen von Typen \textit{zulässig}, (sprich: 
\textit{strikt} und \textit{stetig}) sein.

Auch Voigtländer \cite{voigtlander} beschreibt, was dies für Typkonstruktorvariablen heißt: Allquantifizierte Relationsfunktionen müssen zusätzlich
Striktheit bewahren.
%Wadler stellt einige Bedingungen fest, die an die Typmengen gestellt werden müssen, damit mit Fixpunkten gearbeitet
%werden kann.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Der Striktheitsoperator seq}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Deutlich einschränkender ist es leider, die Gültigkeit von freien Theorem zu erhalten, wenn der Striktheitsoperator \texttt{seq}
vorhanden ist. Dieser hat die folgende Typsignatur.

\begin{minted}{haskell}
seq :: a -> b -> b
\end{minted}

Wie zu sehen ist, erwartet die Funktion zwei Parameter. Obwohl sie auf den ersten Blick ganz gewöhnlich scheint, hat sie
eine bemerkenswerte Eigenschaft, die weitreichende Folgen hat. Der erste Parameter dieser Funktion wird strikt ausgewertet,
anschließend wird der zweite Ausdruck zurückgegeben. Zur Folge hat das, dass der erste Parameter definitiv auf die
Kopf-Normal-Form reduziert wird, unabhängig davon, ob er im zweiten Parameter verwendet wird oder nicht.

Handelt es sich beim ersten Parameter also um $\bot$, wird auch der \texttt{seq}-Aufruf zu $\bot$ ausgewertet, selbst
wenn dieser Ausdruck im durchgereichten Parameter gar keine Verwendung findet.
%ergibt sich daraus ein Fehler, obwohl der erste Parameter
%ansonsten möglicherweise gar keine Verwendung findet.

In Abschnitt \ref{sec:basic-syntax} wurde bereits erwähnt, dass es für Datentypdeklarationen eine spezielle
Syntax gibt, um einzelne Parameter als \textit{strikt} zu deklarieren.
%Bei den Striktheitsannotationen bei Datentypen handelt es sich
%um eine spezielle Schreibweise, um den Striktheitsoperator zu verwenden \todo{besser formulieren}
%Diese Notation wurde bereits kurz in Abschnitt \ref{sec:basic-syntax} erwähnt \todo{nötig?}.
Das folgende Beispiel zeigt eine solche Striktheitsannotation.

\begin{minted}{haskell}
data Annotated = String !SomeData
\end{minted}

Die Annotation im Beispiel bewirkt, dass der Parameter vom Datentyp \texttt{SomeData} stets sofort ausgewertet wird und
folglich auf Kopf-Normal-Form reduziert wird, statt wie üblich Lazy Evaluation anzuwenden.

%Letztere können bei selbstdefinierten
%Datentypen an die einzelnen Untertypen \todo{Richtige Bezeichnung für einzelne "Parameter" eines Datentyps?} annotiert werden,
%um eine strikte Auswertung zu erzwingen.
%Natürlich ergeben sich durch das Auftreten von $\bot$ wiederum Probleme für freie Theoreme, 
Tritt \texttt{seq} auf, so müssen konstruierte Relationen zulässig und bottom-reflexiv sein, um die Gültigkeit der
entsprechenden freien Theoreme zu erhalten.

Diese sehr strenge Einschränkung lässt sich aber zum Teil wieder auflösen, wenn man das resultierende Theorem als
Ungleichung darstellt statt als Gleichung.
Die Idee hinter der Darstellung als Ungleichungen, beschrieben von Johann und Voigtländer \cite{johann}, ist die folgende: Durch Einführen von \texttt{seq} bricht die Gültigkeit der
freien Theoreme auseinander, weil es passieren kann, dass eine Seite der resultierenden Gleichung $\bot$ wird.
Man kann die Aussage jedoch als Ungleichung darstellen, indem man die Typrelationen asymmetrisch konstruiert; sie
ordnen dann nicht mehr jeweils zwei Ausdrücke als ``gleichwertig'' einander zu, sondern legen eine Ordnung fest, die
die \textit{Definiertheit} widerspiegelt \cite{johann}. So bleibt es möglich, gültige Aussagen zu treffen, ohne zu starke
Einschränkungen auf die quantifizierten Relationen festzulegen.

Es soll an dieser Stelle nicht weiter darauf eingegangen werden, wie diese Ungleichungen hergeleitet werden, da dies zu weit
über die eigentliche Thematik hinausgehen würde. Es sei aber erwähnt, dass die Bibliothek \textit{free-theorems} sie bereits
unterstützt, die Typkonstruktorvariablenerweiterung jedoch bisher nur für die \texttt{BasicSubset}-Sprache verfügbar ist.


\subsection{Übersicht}

Insgesamt ergeben sich insgesamt fünf Varianten, für die Böhme \cite{freetheorems} die folgenden Schreibweisen einführt,
wobei $M$ die Menge der verfügbaren Teilsprachen ist.

\begin{align*}
M = \{(basic, =), (fix, =), (fix, \sqsubseteq), (seq, =), (seq, \sqsubseteq)\}
\end{align*}

Je nach gewählter Teilsprache kommen unterschiedliche Relationen bei Allquantifizierungen über Relationen infrage. Tabelle
\ref{tab:relations} listet die unterschiedlichen Relationen auf, wobei die jeweiligen Relationen
stets auf den Typen $T_1, T_2$ definiert sind.

\begin{table}[th]
\centering
\begin{tabular}{| l | l |}
\hline
Bezeichnung & Beschreibung \\
\hline
$Rel^{(fix, =)}(T_1, T_2)$ & Menge aller zulässigen Relationen \\
$Rel^{(fix, \sqsubseteq)}(T_1, T_2)$ & Menge aller zulässigen und links-abgeschlossenen Relationen \\
$Rel^{(seq, =)}(T_1, T_2)$ & Menge aller zulässigen und bottom-reflexiven Relationen \\
$Rel^{(seq, \sqsubseteq)}(T_1, T_2)$ & Menge der zulässigen, totalen und links-abgeschlossenen Relationen \\
\hline
\end{tabular}
\caption{Relationen für die verschiedenen Teilsprachen}
\label{tab:relations}
\end{table}

% TODO: zumindest erklären, welche einschränkungen auf die relationen angewendet werden.

%Die Menge $Rel^{seq}(T_1, T_2)$ beschreibt dabei die Menge aller Relationen auf den Mengen $T_1$ und $T_2$, die zulässig,
%total und links-abgeschlossen sind.

Natürlich müssen auch die relationalen Aktionen dementsprechend angepasst werden. So wird beispielsweise die relationale
Aktion zum Funktionstypkonstruktor in der Teilsprache \texttt{SubsetWithFix} folgendermaßen gebildet.

\begin{align*}
\mathcal{R} \rightarrow^{seq} \mathcal{S} = \{~(f, g)~|~(f \neq \bot \Rightarrow g \neq \bot) \wedge
\forall (x, y) \in \mathcal{R}. (f\ x, g\ y) \in \mathcal{S} \}
\end{align*}