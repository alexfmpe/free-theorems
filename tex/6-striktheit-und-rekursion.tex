% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Striktheit und Rekursion}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\label{sec:striktheit-und-rekursion}

Bisher wurde eine Wahrheit größtenteils ignoriert: Die bisher generierten freien Theoreme sind nur unter ganz bestimmten
Bedingungen gültig. Beim Beispiel \texttt{$test :: [a] \rightarrow [a]$} wurde behauptet, dass die Funktion \texttt{test}
lediglich Ausdrücke aus der Eingabeliste in der Ausgabeliste weiderverwenden könne. Tatsächlich entspricht das nicht ganz der
Wahrheit, denn in Haskell ist zum Beispiel auch denkbar, dass $\bot$ (\textit{bottom}) zurückgegeben wird, beispielsweise
durch Nichtterminierung oder einen Laufzeitfehler.

free-theorems definiert verschiedene Untermengen der Programmiersprache Haskell, zu denen sich unterschiedlich komplexe
Theoreme generieren lassen. Ein Faktor, der nämlich Probleme bereiten kann, ist der Fixpunktoperator.
Die Bilbiothek definiert drei Untermengen:

\begin{itemize}
   \item BasicSubset
   \item SubsetWithFix
   \item SubsetWithSeq
\end{itemize}

Die erste Untermenge, BasicSubset, entspricht dem Girard-Reynoldschen Lambda-Kalkül \cite{freetheorems} \todo{Zitat}, erweitert um Datentypen und
Typklassen \cite{freetheorems}. Insbesondere sind aber keine undefinierten Werte erlaubt, die zum Beispiel durch Nichtterminierung
oder Pattern Matching Fehler auftreten.
Das ändert sich in SubsetWithFix. Hier ist zusätzlich der Fixpunktoperator \textit{fix} verfügbar, und es müssen folglich undefinierte
Werte erlaubt werden. Was noch fehlt, ist die \texttt{seq}-Funktion sowie Striktheits-Flags.

Die Funktion \texttt{seq} hat die folgende Typsignatur.

\begin{minted}{haskell}
seq :: a -> b -> b
\end{minted}

Wie zu sehen ist, erwartet die Funktion zwei Parameter. Obwohl sie auf den ersten Blick ganz gewöhnlich scheint, hat sie
eine bemerkenswerte Eigenschaft, die weitreichende Folgen hat. Der erste Parameter dieser Funktion wird strikt ausgewertet,
schließlich wird der zweite Ausdruck zurückgegeben. Zur Folge hat das, dass der erste Parameter definitiv zuerst auf die
Kopf-Normal-Form reduziert wird, unabhängig vom zweiten Parameter.

Handelt es sich beim ersten Parameter also um $\bot$, ergibt sich daraus ein Fehler, obwohl der erste Parameter
ansonsten möglicherweise gar keine Verwendung findet. Bei den Striktheitsannotationen bei Datentypen handelt es sich
um angenehmere Schreibweisen, um den Striktheitsoperator zu verwenden. Das folgende Beispiel zeigt eine solche
Striktheitsannotation.

\begin{minted}{haskell}
data Test = String !SomeData
\end{minted}

Die Annotation im Beispiel bewirkt, dass der Parameter vom Datentyp \texttt{SomeData} stets sofort ausgewertet wird und
folglich auf Kopf-Normal-Form reduziert wird.
 

%Letztere können bei selbstdefinierten
%Datentypen an die einzelnen Untertypen \todo{Richtige Bezeichnung für einzelne "Parameter" eines Datentyps?} annotiert werden,
%um eine strikte Auswertung zu erzwingen.
Die Untermenge SubsetWithSeq ist die Sprache, die auch \texttt{seq} und Striktheitsannotationen enthält.

Es wird noch eine weitere Unterscheidung eingeführt: Zu SubsetWithFix und SubsetWithSeq kann noch unterschieden werden,
ob die Theoreme als Gleichungen oder als Ungleichungen erwünscht sind.

Die Idee hinter der Darstellung als Ungleichungen ist die folgende: Durch Einführen von \texttt{seq} bricht die Gültigkeit der
freien Theoreme auseinander, weil es passieren kann, dass eine Seite der resultierenden Gleichung $\bot$ sein kann.
Man kann die Aussage jedoch als Ungleichung darstellen, indem man die Typrelationen asymmetrisch konstruiert; sie
ordnen dann nicht mehr jeweils zwei Ausdrücke als ``gleichwertig'' einander zu, sondern legen eine Ordnung fest, die
die \textit{Definiertheit} widerspiegelt \cite{johann}. So bleibt es möglich, gültige Aussagen zu treffen, ohne zu starke
Einschränkungen auf die quantifizierten Relationen festzulegen.

Insgesamt ergeben sich insgesamt fünf Varianten, für die \cite{freetheorems} die folgende Schreibweise einführt,
wobei $M$ die Menge der verfügbaren \textit{Modelle} ist:

\begin{align}
M = \{(basic, =), (fix, =), (fix, \sqsubseteq), (seq, =), (seq, \sqsubseteq)\}
\end{align}

% TODO: zumindest erklären, welche einschränkungen auf die relationen angewendet werden.