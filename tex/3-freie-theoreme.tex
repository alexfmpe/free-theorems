% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Freie Theoreme}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\label{sec:freie-theoreme}

In der Einleitung wurde bereits kurz thematisiert, dass man allein durch Betrachten der Typsignatur einer Funktion bereits
eine grundlegende, intuitive Vorstellung davon erhalten kann, welche Funktionalität sich ungefähr hinter dieser Funktion
verbirgt. Haskells Typsystem sorgt dafür, dass Funktionen in ihren Implementierungsmöglichkeiten
teilweise stark eingeschränkt sind. Der Grund hierfür ist der parametrische Polymorphismus, der in Haskellfunktionen
mit Typvariablen Anwendung findet. Nicht nur verringert das Typsystem die Fehleranfälligkeit von produziertem
Code, es vereinfacht auch Rückschlüsse auf die Funktionsweise und Korrektheitsbeweise.

Außerdem wurde bereits angedeutet, dass es eine Möglichkeit gibt, systematisch Theoreme zu gegebenen Typsignaturen
herzuleiten. Diese sogenannten \textit{freien Theoreme}, ihre Herleitung und ihre Verwendung sind Thema dieses Kapitels.
Zunächst wird an einem Beispiel
erläutert, wie die Vorgehensweise intuitiv zu erklären ist. Der darauf folgende Abschnitt behandelt die formale Herleitung
eines freien Theorems zu einer beliebigen Typsignatur nach Wadler \cite{wadler}.

Daraufhin wird die Erweiterung des Vorgehens um Typkonstruktorklassen thematisiert, wie sie
auch von Voigtländer verwendet wird \cite{voigtlander}. Am Ende des Kapitels wird schließlich an einem
praktischen Beispiel gezeigt, wie ein freies Theorem für einen Beweis verwendet werden kann.

%Wie in der Einleitung bereits angedeutet wurde, lässt sich diese Intuition in Formeln ausdrücken. In diesem Abschnitt
%wird erklärt, wie diese so genannten freien Theoreme aussehen. Es wird erläutert, wie man sie herleitet und warum
%das möglich ist. Am Ende des Abschnittes wird insbesondere darauf eingegangen, welche Rolle Typkonstruktorklassen
%für die Generierung von freien Theoremen spielen.

%Einleitend wurde bereits das mächtige Typsystem Haskells angesprochen. Dieses Typsystem ist komplett statisch und
%unterstützt parametrischen Polymorphismus, wie in den Grundlagen erläutert wurde. Nicht nur verringert ein solches Typsystem
%die Fehleranfälligkeit von produziertem Code, es vereinfacht auch Rückschlüsse auf die Funktionsweise und Korrektheitsbeweise.
%In dieser Arbeit geht es vor allem um die bereits angesprochenen freien Theoreme. Diese lassen sich herleiten, ohne dass man
%überhaupt die konkrete Implementierung in Betracht ziehen muss. Man nennt sie ``freie Theoreme'', weil man sie gewissermaßen
%``geschenkt'' bekommt. Wie genau man diese Theoreme herleitet, soll in diesem Abschnitt genauer erläutert werden.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Intuition}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Bevor die theoretische Herangehensweise beschrieben wird, bietet es sich zunächst an, die Vorgehensweise intuitiv an einem
Beispiel zu erklären. Dabei werden noch keine Definitionen eingeführt oder Formeln aufgestellt, es geht vielmehr darum,
ein Gefühl dafür zu vermitteln, warum es überhaupt möglich sein soll, Theoreme allein aus der Signatur eines Ausdrucks
abzuleiten. Im nächsten Abschnitt wird dieses Vorgehen dann konkretisiert und für beliebige Typsignaturen verallgemeinert.

%Als Beispiel soll die folgende Haskell-Typsignatur dienen.
Als einfaches Beispiel dient die Funktion mit der folgenden Typsignatur.

%Zunächst bietet es sich an, die Vorgehensweise an einem konkreten Beispiel vorzuführen. Bevor es um die theoretische
%Herangehensweise geht, soll das Vorgehen erst einmal intuitiv motiviert werden. Wir betrachten die folgende Haskell-Funktion.

\begin{align}
f :: [a] \rightarrow [a] \label{eq:fsig}
\end{align}

Gegeben ist also eine Funktion $f$, die eine Liste auf eine Liste abbildet. Das Besondere an dieser Funktion ist, dass sie
nicht für einen konkreten Typ wie beispielsweise $Integer$ deklariert ist, sondern dass man sie für jeden
beliebigen Typ instanziieren kann, indem man die Typvariable $a$ durch einen Typausdruck ersetzt. Die Funktion ist also für
jeden beliebigen Typ deklariert, es handelt sich um eine \textit{polymorphe Funktion}.

Bei der Typvariable $a$ handelt es sich erst einmal um eine ungebundene, \textit{freie} Variable. Man kann sich aber einen impliziten
Allquantor vor der eigentlichen Signatur denken. Tatsächlich existiert dieser Allquantor sogar als spezielles Schlüsselwort \texttt{forall} in Haskell,
wie die folgende Schreibweise zeigt\footnote{Um die forall-Notation verwenden zu können, muss allerdings die \texttt{ExistentialQuantification}-Spracherweiterung aktiviert werden.}.

\begin{minted}{haskell}
f :: forall a. [a] -> [a]
\end{minted}

Im Normalfall wird dieses Schlüsselwort jedoch nicht explizit benötigt und deshalb meistens weggelassen. Immer, wenn
freie Typvariablen in einer Signatur vorkommen, lässt sich diese Signatur also \textit{schließen}, indem für jede freie Typvariable
ein entsprechender Allquantor an den Anfang gesetzt wird.

Die Instanziierung einer polymorphen Funktion auf einen konkreten Typ wird im weiteren Verlauf der Arbeit notiert, indem der
polymorphe Ausdruck mit einem Index versehen wird, der dem Typ entspricht, auf den der Ausdruck instanziiert wird.
$f_{Integer}$ ist dann beispielsweise die Funktion $f$, konkretisiert auf den Typ Integer, d.h. es wird Integer
für jedes $a$ in die Funktionssignatur eingesetzt. $f_{Bool \rightarrow Bool}$ wäre folglich die gleiche Funktion, instanziiert auf den Typ
$Bool \rightarrow Bool$, sie hätte also die Signatur $[Bool \rightarrow Bool] \rightarrow [Bool \rightarrow Bool]$.

Hat die Funktion mehrere verschiedene Typvariablen, so werden die einzelnen Typen
in der Reihenfolge des Auftretens der zu ersetzenden Typvariablen angegeben. Eine Funktion mit der Signatur \texttt{g :: a -> b} instanziiert man
folglich mit $g_{Integer\ String}$ auf den Typ $Integer \rightarrow String$.

%Instanziierung einer polymorphen Funktion auf einen bestimmten Typ wird im Folgenden
%durch eine Index-Schreibweise dargestellt. $f_{Integer}$ wäre also eine Funktion mit dem Typen $[Integer] \rightarrow [Integer]$,
%$f_{Bool}$ wäre die gleiche Funktion für den Typen $[Bool] \rightarrow [Bool]$.
%3sie für jeden beliebigen Typen,
%der für die Typvariable a eingesetzt werden
%kann. Es handelt sich also um eine polymorphe Funktion.

Ein entscheidendes Detail bei polymorphen Funktionen in Haskell ist die Art des Polymorphismus.
Man unterscheidet zwischen Ad-Hoc Polymorphismus und parametrischem Poly\-mor\-phis\-mus \cite{strachey}. Bei Typvariablen
in Haskell handelt es sich um parametrischen Polymorphismus, das heißt die entsprechende Funktion arbeitet für sämtliche
eingesetzten Typen nach demselben Prinzip.

Erst einmal klingt das nicht besonders außergewöhnlich, es zieht aber wichtige
Konsequenzen mit sich. ``Dasselbe Prinzip'' heißt hier nämlich, dass unabhängig vom eingesetzten Typ die gleichen
Berechnungen stattfinden. Die Funktion kann nicht einmal
durch Fallunterscheidung ermitteln, um welchen konkreten Typ es sich im jeweiligen Fall handelt.
%In diesem Fall handelt es sich um parametrischen Polymorphismus, d.h. die Funktion arbeitet für sämtliche Typen nach dem gleichen Prinzip.

Das ist deswegen etwas Besonderes, weil dadurch ermöglicht wird, allgemeine Aussagen zu treffen, die für sämtliche
Typinstanziierungen gelten. Vergleicht man diese Methode mit der zweiten Art von Polymorphismus, dem \textit{Ad-Hoc-Polymorphismus},
wird der Vorteil klar: Unter Letzterem versteht man, dass eine Funktion zwar für verschiedene Typen definiert wird, diese jedoch
jeweils eine konkrete, typspezifische Implementierung haben.

Es handelt sich also technisch gesehen um verschiedene Funktionen, die sich einen Namen teilen können, weil anhand der Typsignatur
und der Typen der Parameter, mit denen die Funktion aufgerufen wird, entschieden werden kann, welche der Funktionen jeweils gemeint ist.
Ein Beispiel für Ad-Hoc-Polymorphismus bietet die Programmiersprache \textit{C++} \cite{cpp}: Hier ist es möglich, mehrere Funktionen mit gleichem
Namen in einer Klasse zu deklarieren, solange die Parameter unterschiedliche Signaturen besitzen, wie Listing \ref{lst:c-example} zeigt.

\begin{listing}[ht]
\begin{minted}{cpp}
class Log
{
public:
   void log(TextObject* t);
   void log(Image* t);
   void log(Test* t);
}
\end{minted}
\caption{Ad-Hoc-Polymorphismus in C++}
\label{lst:c-example}
\end{listing}

Hier werden drei Methoden deklariert, die alle den Namen \texttt{log} haben, sich jedoch durch den Typ des Parameters
unterscheiden. Die jeweilige Implementierung, die hier nicht zu sehen ist, kann sich von Funktion zu Funktion komplett unterscheiden.
Auch Haskell bietet mit den in der Einleitung bereits eingeführten \texttt{Typklassen} Ad-Hoc-Polymorphismus \cite{adhoc}.
%. Darauf wird später noch genauer eingegangen.

Beim Ad-Hoc-Polymorphismus kann also jede Funktion eine eigene Implementierung haben, außerdem ist jeder Funktion
bekannt, auf welchem Typ sie arbeitet, was es ihr ermöglicht, typspezifische Operationen anzuwenden. Es liegt nahe, dass dies
allgemeingültige Aussagen über solche Funktionen sehr stark einschränkt.

%Die Implementierungen können also komplett unterschiedlich funktionieren und kennen den konkreten Typen, für de%n sie
%implementiert sind, können also auf typspezifische Eigenschaften zugreifen. Man kann sich denken, dass das allgemeine Aussagen
%unmöglich macht.

Wir betrachten wieder die Beispielfunktion $f$ aus (\ref{eq:fsig}). Durch parametrischen Polymorphismus ist sie also für jeden beliebigen
Typ $a$ definiert. Das hat Konsequenzen für die Funktionsweise dieser Funktion.

Man kann sich an dieser Stelle die Frage stellen: Wie kann die Funktion die Liste erzeugen, die sie zurückgeben muss? Sie kennt den konkreten Typ nicht,
das heißt sie kann keine neuen Elemente ``erfinden'', weil sie keine Informationen darüber hat, welchen Typ die Listenelemente haben müssen.
Und Ausdrücke, die zu jedem beliebigen Typ passen, gibt es in Haskell
nicht\footnote{Tatsächlich kann man undefinierte Werte als Ausdrücke ansehen, die zu einem beliebigen Typ generiert werden können --
diese werden jedoch erst einmal außen vor gelassen. In Kapitel \ref{sec:striktheit-und-rekursion} wird etwas genauer darauf eingegangen.}.
Eine Möglichkeit hat sie aber dennoch: Sie kann die Elemente der Eingabeliste wiederverwenden.
Die einzige Möglichkeit für die Funktion, die Liste zu ändern, besteht also in einer Umsortierung der Listenelemente.

Doch auch für eine Neusortierung der Liste hat die Funktion wenige Anhaltspunkte. Sie kennt zwar die Länge der Liste, doch ohne Kenntnis des Typen kann sie keine weiteren Aussagen über den Inhalt der einzelnen Listenelemente treffen (und da die Klasse Eq
nicht gegeben ist, nicht mal über deren Gleichheit). Auch hat sie aufgrund der referenziellen Transparenz %\todo{kann man das hier einfach so einstreuen?}
in Haskell keinen globalen Kontext oder Ähnliches, anhand dessen sie Entscheidungen treffen könnte.
Sie wird also gezwungenermaßen je zwei Listen gleicher Länge stets gleich behandeln.
%Sie wird also für zwei Listen gleicher Länge $l$ und $l'$ exakt das Gleiche tun.

In der Einleitung wurde bereits die Haskell-Funktion \texttt{map} eingeführt, die eine Funktion auf jedes Element einer Liste
anwendet und eine Liste gleicher Länge zurückgibt, in dem jedes Element durch die Eingabefunktion manipuliert wurde.

%Bevor weiter argumentiert werden kann, soll an dieser Stelle eine bekannte Funktion aus Haskell eingeführt werden. Die Funktion
%\texttt{$map :: (a \rightarrow b) \rightarrow [a] \rightarrow [b]$} erwartet eine Funktion als ersten Parameter und eine Liste als
%zweiten Parameter. Sie erzeugt aus der Liste eine neue Liste gleicher Länge, indem jedes Element mit der übergebenen Funktion in
%ein neues Element überführt wird.

Haskell verwendet für Funktionsapplikation das Prinzip des Currying, das heißt, dass eine Funktion, die auf ein
Argument angewandt wird, eine neue Funktion zurückgibt, in der dieses Argument fest gesetzt ist, die also einen Parameter weniger erwartet.
Man kann die $map$-Funktion also auch anders interpretieren als Funktion, die eine Funktion als Parameter erwartet und eine
neue Funktion zurückgibt. Diese neue Funktion erwartet wiederum eine Liste als Parameter und gibt eine Liste zurück.

Der folgende Ausdruck wandelt also gewissermaßen die Eingabefunktion \texttt{f} in eine neue Funktion um, die die Funktionalität von
\texttt{f} für Listen bietet.

\begin{minted}{haskell}
map f
\end{minted}

Man kann auch sagen: \texttt{map} \textit{liftet} die Funktion \texttt{f} in den Listen-Kontext.
Im Folgenden nehmen wir an, dass die Funktion $f$ auf einen beliebigen konkreten Typ instanziiert wurde.
Wir betrachten jetzt eine beliebige nicht-polymorphe Funktion $g$, die auf diesem konkreten Typ arbeitet. $map\ g$ liefert folglich eine Funktion,
die $g$ auf sämtliche Elemente einer Eingabeliste
anwendet. Jede Liste, die durch Anwendung von $map\ g$ entsteht, wird die gleiche Anzahl an Elementen haben wie die ursprüngliche Liste.
Darüber hinaus vertauscht $map\ g$ die Listenelemente nicht, jedes neue Element wird an derselben Stelle stehen wie
sein Ursprungselement.

Auf dieser Argumentation aufbauend kann man erkennen, dass es unerheblich für die Ergebnisliste ist, ob man zuerst die
Funktion $f$ auf eine Liste appliziert und dann auf die resultierende Liste die Funktion $map\ g$ anwendet, oder ob man
in umgekehrter Reihenfolge vorgeht. Abbildung \ref{fig:fmapg} veranschaulicht dies für eine Beispielfunktion $f$, die Listen
umkehrt, und eine Funktion $g$, die zu jedem Listenelement den Wert $1$ hinzuaddiert. Hervorgehoben ist die Position
eines Elements in dieser Liste. Im linken Teil der Abbildung wird zunächst die Funktion $f$ appliziert und als zweites
$map\ g$, im rechten Teil wird $map\ g$ zuerst angewendet und dann erst $f$.

\begin{figure}[ht]
\centering
\includegraphics[width=430px]{fmapg}
\caption{Die Reihenfolge der Anwendung von $f$ und $map\ g$ spielt keine Rolle für die Ergebnisliste.}
\label{fig:fmapg}
\end{figure}

%Die folgende Formel fasst diese Aussage mathematisch zusammen.
Die folgende Formel fasst die Aussage der obigen Argumentation als mathematische Aussage zusammen.


%Die Haskell-Funktion \texttt{$map :: (a \rightarrow b) \rightarrow [a] \rightarrow [b]$} wendet eine Funktion auf jedes Element einer Liste an und gibt die resultierende Liste zurück. Da Haskell Currying für Funktionsapplikation verwendet, kann man
%diese Funktion auch auf eine andere Weise interpretieren: $map$, angewandt auf eine Funktion, liftet diese in den Listen-Kontext,
%gibt also eine Funktion zurück, die dieselbe Funktionalität für Listen bietet. Betrachten wir nun eine beliebige Funktion $g :: a \rightarrow a$. Es lassen sich jetzt Aussagen über $map\ g$, angewandt auf Listen, treffen. Zum einen wird jede Liste, auf die man $map\ g$ anwendet, die gleiche Länge haben wie vorher - das liegt einfach in der Natur von $map$.

%Darüber hinaus müssen jeweils zwei Elemente, die an der gleichen Position stehen, auf die gleiche Weise entstanden sein, nämlich
%durch Anwenden von $g$ auf das entsprechende Listenelement.
%Es ist nun logisch, dass es egal ist, ob man zuerst die Funktion f auf eine Liste anwendet und dann die Funktion g auf die
%resultierende Liste mappt, oder ob man in umgekehrter Reihenfolge vorgeht.

\begin{align*}
f (map\ g\ l) = map\ g\ (f\ l)
\end{align*}

Diese Aussage ist ein Theorem, das für beliebige Funktionen $g$ und beliebige Listen $l$ gilt. Hierbei ist zu beachten, dass $g$ hier
keine polymorphe Funktion ist, es ist eine beliebige Funktion, die auf dem \textit{konkreten} Typ von $f$ arbeitet d.h. auf dem Typ,
auf den $f$ instanziiert wird. Ebenso handelt es sich bei $l$ um eine Liste ebendieses konkreten Typs.

Das Bemerkenswerte ist jedoch nicht diese allgemeine Aussage an sich, sondern die Grundlage, auf der sie getroffen wurde.
Überlegt man sich einmal, anhand welcher Informationen diese Schlussfolgerung gezogen wurde, wird klar, dass das einzige für
diese Herleitung benötigte Wissen die Typsignatur der Funktion $f$ ist.
Insbesondere wurde die Funktion nicht auf einen konkreten Typ instanziiert, die Aussage gilt für beliebige Typen.
%, d.h. für
%beliebige Funktionen mit der Typsignatur $[a] \rightarrow [a]$.

%Wir haben für
%die Herleitung kein Wissen über die konkrete Implementierung der Funktion f benötigt; das einzig Bekannte war die Typsignatur.
%Das Theorem gilt also insbesondere für alle Funktionen mit der Typsignatur $[a] \rightarrow [a]$. Da man dieses Theorem
%aus der Typsignatur gwissermaßen ``geschenkt'' bekommt, nennt man es auch ``freies Theorem''.

Natürlich war die vorangegangene Herleitung sehr unkonkret und nicht wirklich mathematischer Natur. Im Folgenden wird dieser
intuitive Ansatz nun mathematisch konkretisiert.
%Daher soll im Folgenden
%erklärt werden, wie man freie Theoreme im Allgemeinen und vor allem auf mathematischer Grundlage herleitet.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Parametrizität}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\label{sec:free-theorems-param}

Der Schlüssel zur Herleitung von freien Theoremen liegt in der Betrachtung von Typen.
Intuitiv werden Typen häufig als Mengen aufgefasst. So würde man den Typ \texttt{Bool} beispielsweise als Menge $\mathbb{B}$
der booleschen Werte auffassen mit $\mathbb{B} = \{ tt, ff \}$, der Typ \texttt{Integer} wäre die Menge der ganzen Zahlen
$\mathbb{Z}$ usw. Komplexere Typen ergeben sich dann durch Zusammensetzung aus einzelnen Basistypen, beispielsweise
würde man den Typen \texttt{$Integer \rightarrow Integer$} auffassen als die Menge $(\mathbb{Z} \rightarrow \mathbb{Z})$ aller Funktionen von den ganzen Zahlen in die ganzen Zahlen.

Die grundsätzliche Idee hinter freien Theoremen basiert auf der Erkenntnis von Reynolds, dass die Semantik eines beliebigen
Ausdrucks verwandte Umgebungen auf verwandte Werte abbildet \cite{reynolds}. Dieses Theorem, von Reynolds das
\textit{Abstraktionstheorem} genannt, wird von Wadler umformuliert zum sogenannten \textit{Parametrizitätstheorem} \cite{wadler},
das diese Erkenntnis für polymorphe Funktionssignaturen nutzbar macht und die Herleitung von Theoremen ermöglicht.
Das heißt allerdings, dass man Typen als Relationen auffassen muss statt als Mengen, um dieses Theorem anwenden zu können.
%vorausgesetzt, die Typen werden als Relationen aufgefasst statt als Mengen.

Um Typen als Relationen aufzufassen, definiert man sogenannte \textit{relationale Aktionen}, mit denen zu jedem Typ eine entsprechende Relation
konstruiert werden kann. Johann und Vogitländer definieren relationale Aktionen wie folgt \cite{johann2006}.

\begin{mydef}[Relationale Aktion]
Zu jedem $n$-stelligen Typkonstruktor wird eine Abbildung definiert, die aus $n$ Relationaldarstellungen eine neue Relation konstruiert.
Diese Abbildung nennt man relationale Aktion.
%Eine relationale Aktion ist eine map ??, die eine Anzahl 
\end{mydef}

%das im Folgenden erläutert werden soll. Entscheidend ist, dass man Typen nicht als Mengen sondern als Relationen ausdrückt,
%um dieses Theorem anwenden zu können.

%Für die Herleitung von freien Theoremen ist diese Repräsentation nicht ganz ausreichend, da sie spätestens bei polymorphen
%Typen auf beweistechnische Probleme stößt \todo{?}. Daher greift man auf eine etwas andere Repräsentation zurück: Man
%betrachtet Typen als Relationen.

%Man kann zu einem Typen nun systematisch eine Relation konstruieren, die diesen Typen repräsentiert. Dazu geht man
%folgendermaßen vor:

Man kann also zu einem beliebigen Typ eine Relation konstruieren, die diesen Typ repräsentiert, indem man zu jedem Typkonstruktor
die entsprechende relationale Aktion anwendet. Die einzelnen Relationen werden nach Voigtländer \cite{voigtlander} folgendermaßen konstruiert, wobei wir die Menge aller Typmengen als $Typen$ bezeichnen.

\begin{itemize}
\item Zu jedem Basistyp $T$ (\texttt{Int}, \texttt{Bool}, etc.) ist die zugehörige Relation die Identitätsrelation $\mathcal{R} = id_{T} = \{~(x, x)~|~x \in T~\}$.
\item Sind $\mathcal{R} : R_1 \Leftrightarrow R_2$ und $\mathcal{S} : S_1 \Leftrightarrow S_2$ Typrelationen, so ist
\begin{align*}
\mathcal{R} \rightarrow \mathcal{S} = \{ (f, g) ~|~ & f \in (R_1 \rightarrow S_1), g \in (R_2 \rightarrow S_2),\\
& \forall x \in R_1, y \in R_2: (f\ x, g\ y) \in \mathcal{S} \}
\end{align*}
die zugehörige Funktionstyprelation.
\item Ist $\mathcal{F}(\mathcal{X})$ eine Typrelation, die von einer Typrelation $\mathcal{X} : X \Leftrightarrow X'$ abhängt,
dann definiert man
\begin{align*}
\forall \mathcal{X} . \mathcal{F}(\mathcal{X}) = \{~(x, y)~|~& x \in X, y \in X', \forall A_1, A_2 \in Typen,\\
&\forall \mathcal{A} : A_1 \Leftrightarrow A_2.~ (x_{A_1}, y_{A_2}) \in \mathcal{F}(\mathcal{A})~\}
\end{align*}
Hierbei sind $x$ und $y$ polymorphe Ausdrücke.
% , die durch $x_{A_1}$ und
%$y_{A_2}$ auf einen bestimmten Typ instanziiert werden.
\end{itemize}

%Zudem lassen sich bestimmte Typkonstruktoren, wie beispielsweise der Listenkonstruktor $[a]$, durch Lifting der betreffenden
%Relation umsetzen. Man kann beispielsweise für eine gegebene Typrelation $\mathcal{R} : T_1 \Leftrightarrow T_2$ folgenes
%Lifting definieren.

Die Konstruktion zu Basistypen sagt ganz einfach, dass in der resultierenden Relation jeder Wert nur mit sich selbst verwandt ist.
Betrachten wir als Beispiel die Relation zum Typ \texttt{Bool}. Als Menge aufgefasst stellt sich dieser Datentyp dar wie folgt.

\begin{align*}
Bool = \{~True, False~\}
\end{align*}

Die zu diesem Typ konstruierte Relation ist nun die Identitätsrelation, $True$ ist also mit $True$ verwandt, $False$ ist mit $False$ verwandt.
Sonstige Beziehungen gibt es nicht zwischen den Werten.

Funktionstypkonstruktoren bauen auf zwei bereits bestehenden Typrelationen $\mathcal{R}$ und $\mathcal{S}$ auf. Wir bleiben beim einfachen
Beispiel \texttt{Bool} und erweitern die Signatur zum Typ \texttt{Bool -> Bool}.

Induktiv werden nun also zunächst die Relationen zu den Basistypen konstruiert, in diesem Fall $id_{Bool}$. Darauf aufbauend
wird dann aus den zwei Identitätsrelationen die Funktionstyprelation gebaut. Die Intuition hinter der oben gegebenen Formel ist
die folgende: Es wird eine Relation von Funktionen konstruiert, in denen zwei Funktionen genau dann verwandt sind, wenn sie
verwandte Parameter auf verwandte Ergebnisse abbilden.

Die Konstruktion $id_{Bool} \rightarrow id_{Bool}$, die sich aus dem Beispiel ergibt, führt also zu einer Relation
$\mathcal{R} : (Bool \rightarrow Bool) \Leftrightarrow (Bool \rightarrow Bool)$, in der solche Funktionen verwandt sind,
die verwandte Argumente aus der ersten Relation auf verwandte Ergebnisse in der zweiten Relation abbilden. Da es sich bei
beiden Relationen um Identitätsrelationen handelt, können nur gleiche Werte verwandt sein, und somit können auch nur
Funktionen verwandt sein, die gleiche Werte auf gleiche Werte abbilden -- es können also auch nur gleiche Funktionen verwandt
sein.

Alle Basistypen und alle Funktionen auf Basistypen sind also Identitätsrelationen. Bis hierhin bringt die Verwendung von Relationen
statt Mengen noch keinen
wirklichen Vorteil, da immer wieder Identitätsrelationen entstehen. Interessant wird es erst beim Auftreten von Typabstraktionen der
Form
$\forall \mathcal{R} . \mathcal{F}(\mathcal{R})$, wobei $\mathcal{F}(\mathcal{R})$ eine Relation ist, die von einer Relation
$\mathcal{R}$ abhängt. Wie in der obigen Definition der entsprechenden \textit{relationalen Aktion} beschrieben, sind zwei Werte dann verwandt bezüglich der
konstruierten Relation, falls sie bezüglich jeder Relation $\mathcal{A}$ auf beliebigen Typen verwandt sind, sofern sie auf deren
jeweiligen Typ instanziiert werden.

Auch für Datentypen lassen sich Relationen konstruieren. Ein Beispiel ist der Listentypkonstruktor \texttt{[]}, für den man folgende
relationale Aktion rekursiv definiert, wenn eine Typ\-re\-lati\-on $\mathcal{R} : T_1 \Leftrightarrow T_2$ gegeben ist.

\begin{align*}
[\mathcal{R}] = \{ ([], []) \} \cup \{ (a : as, b : bs) ~|~ (a, b) \in \mathcal{R}, (as, bs) \in [\mathcal{R}] \}
\end{align*}

Andere Standardtypkonstruktoren lassen sich auf ähnliche Weise beschreiben. Nun haben wir die Mittel, zu jeder vorhandenen
Typsignatur eine Relation zu konstruieren. Eine entscheidende Erkenntnis von Wadler \cite{wadler}, aufbauend auf
Reynolds \cite{reynolds}, ist nun das Parametrizitätstheorem. Hierzu muss noch der Begriff \textit{geschlossener Term} definiert werden.

\begin{mydef}
Ein Term ist geschlossen, wenn er keine freien Termvariablen enthält.
\end{mydef}

Diese Definition ist zwar relativ selbsterklärend, ist aber wichtig für das folgende Theorem, da dieses Theorem von geschlossenen
Termen ausgeht.

\begin{mytheorem}[Parametrizität]
Ist t ein geschlossener Term von Typ T und $\mathcal{T}$ die zugehörige konstruierte Typrelation, dann gilt $(t, t) \in \mathcal{T}$.
\end{mytheorem}

%folgende: Ist t ein geschlossener Term von Typ T und $\mathcal{T}$ die zugehörige konstruierte
%Typrelation, dann gilt $(t, t) \in \mathcal{T}$ (dieser Satz wird von \cite{wadler} auch Parametrizität, \textit{Parametricity}, genannt).
Damit ist alles gegeben, was man zur Herleitung des freien Theorems benötigt. Wir untersuchen wieder das Beispiel
$f :: [a] \rightarrow [a]$. Durch Parametrizität ist gegeben:

\begin{align*}
(f, f) \in \forall \mathcal{R} . [\mathcal{R}] \rightarrow [\mathcal{R}]
\end{align*}

%Dabei ist zu bemerken, dass in Haskellsyntax typischerweise die Allquantifizierung über die Typvariable weggelassen wird.
Es wurde bereits zu Beginn des Kapitels erwähnt, dass freie Typvariablen in Signaturen mit einem impliziten Allquantor
quantifiziert werden, weshalb hier die entsprechende relationale Aktion Anwendung findet.
%Implizit ist $[a] \rightarrow [a]$ aber gleichbedeutend mit $\forall a . [a] \rightarrow [a]$.
Wir können nun Schritt für Schritt die Definitionen der einzelnen Relationskonstruktionen anwenden, wodurch die Formel
abgerollt wird.

\begin{align*}
&\forall A_1, A_2 \in Typen, \mathcal{A} : A_1 \Leftrightarrow A_2: \\
&\hphantom{\forall} (f_{A_1}, f_{A_2}) \in [\mathcal{A}] \rightarrow [\mathcal{A}] \\
& \\
\Leftrightarrow ~&
\forall A_1, A_2 \in Typen, \mathcal{A} : A_1 \Leftrightarrow A_2: \\
&\hphantom{\forall} \forall (l, l') \in [\mathcal{A}]: \\
&\hphantom{\forall \forall} (f_{A_1} l, f_{A_2} l') \in [\mathcal{A}] \\
& \\
%\Leftrightarrow &
%\forall A_1, A_2 \in Typen, \mathcal{A} : A_1 \Leftrightarrow A_2: \\
%& \forall (l, l') \in lift_{[]}(\mathcal{A}): \\
%& (f_{A_1} l, f_{A_2} l') \in lift_{[]}(\mathcal{A}) \\
\end{align*}

%Zur Erinnerung: $\mathcal{A} : A_1 \Leftrightarrow A_2$ bedeutet, dass $\mathcal{A}$ eine Relation auf den Mengen $A_1$ und $A_2$ ist.

An diesem Punkt haben wir eine Aussage über beliebige Typrelationen $\mathcal{A}$, anschaulicher wäre aber eine Aussage
über beliebige Funktionen. Da man Funktionen als Spezialfall von Relationen betrachten kann, können wir die Aussage
spezifizieren für den Fall, dass es sich bei $\mathcal{A}$ um eine Funktion handelt. Wir quantifizieren dazu statt
über alle Relationen $\mathcal{A} : A_1 \Leftrightarrow A_2$ über alle Funktionen $g : A_1 \rightarrow A_2$.

%Wie in den Grundlagen erläutert wurde, kann man eine Allquantifizierung über Relationen spezialisieren auf Funktionen,
%das heißt wir können uns auf alle $g : A_1 \rightarrow A_2$ beschränken.
%Eine Funktion $f : S \rightarrow T$ kann man auch betrachten als Relation $\{ (x, f x) | x \in S \}$. Anders gesagt: Ist
%$\mathcal{F} : T_1 \Leftrightarrow T_2$ eine Relation zu einer Funktion f, dann gilt für alle $(x, y) \in \mathcal{F}: f x = y$.
%Schränken wir also unsere Aussage auf Funktionen ein, können wir über alle Funktionen $g : A_1 \rightarrow A_2$ quantifizieren. 
Aus dem abgerollten Parametrizitätstheorem haben wir ja bisher die Aussage abgeleitet, dass für alle Parameter $l, l' \in [\mathcal{A}]$
die Aussage $(f_{A_1} l, f_{A_2} l') \in [\mathcal{A}]$ gilt.
Als Funktion geschrieben heißt das, es gilt die folgende Aussage, wobei der Ausdruck $lift_{[]}(g)$ bedeuten soll, dass die Funktion $g$ in
den Listenkontext gehoben wird (die Schreibweise $[g]$ würde zu unnötigen Mehrdeutigkeiten führen).

\begin{align*}
lift_{[]}(g) (f_{A_1}\ l) = f_{A_2}\ l'
\end{align*}

Das Lifting von Funktionen in den Listenkontext kann man auch anders ausdrücken als das Mapping dieser Funktionen auf Listen, sprich:
die Haskell-Funktion $map$, angewandt auf die entsprechende Funktion.

\begin{align*}
map\ g\ (f_{A_1}\ l) = f_{A_2}\ l'
\end{align*}

Hierbei ist zu bemerken, dass nun nicht mehr über alle Paare $(l, l') \in [\mathcal{A}]$
quantifiziert werden muss, da es zu jedem $l \in [A_1]$ nur genau ein $l' \in [A_2]$ geben kann, für das gilt $map\ g\ l = l'$. Folglich kann man die Variable $l'$
weglassen und stets den Ausdruck $map\ g\ l$ verwenden.
%Da $(l, l') \in [A]$, können wir $l'$ auch anders ausdrücken als $map\ g\ l = l'$. Man erhält also:
Ersetzt man die Variable $l'$ also entsprechend, so erhält man die folgende Aussage.

\begin{align*}
map\ g\ (f_{A_1} l) = f_{A_2} (map\ g\ l)
\end{align*}

Und man erkennt: Es handelt sich um die gleiche Aussage, die wir vorher intuitiv konstruiert haben. Jetzt haben wir bewiesen,
dass sie gültig ist, da Parametrizität gilt. Und ein Theorem dieser Art lässt sich für jede beliebige Typsignatur herleiten.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Typkonstruktorklassen und -variablen}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\label{sec:typkonstruktorklassen}

Die bisherige Theorie basierte auf Wadler \cite{wadler} und sah kein Auftreten von Typklassen oder Typkonstruktorklassen vor.
In Abschnitt \ref{sec:free-theorems-param} wurde angegeben, wie beispielsweise der Listendatentyp in eine Relationaldarstellung
überführt werden kann, und auf dieselbe Art und Weise lassen sich entsprechende Repräsentationen für beliebige Datentypen
herleiten, so zum Beispiel $Maybe$, wie das folgende Beispiel zeigt.

\begin{align*}
Maybe\ \mathcal{R} = \{~(Nothing,\ Nothing)~\} \cup \{~(Just\ x, Just\ y)~|~(x, y) \in \mathcal{R} \}
\end{align*}

Dass in Typsignaturen aber nicht nur über Typvariablen, sondern auch über Variablen allquantifiziert werden kann, die
ihrerseits nicht Platzhalter für spezielle Typen, sondern für Typkonstruktoren sind, wurde bisher außer Acht gelassen. In diesem
Abschnitt geht es nun also um Typkonstruktorvariablen von der Sorte $* \rightarrow *$, wie es von Voigtländer \cite{voigtlander}
vorgestellt wird. In der Einleitung wurde bereits die Funktion $fmap$ als Beispiel angegeben, die die folgende Typsignatur besitzt.
%Es wurden jetzt 

%Eine Sache, die bisher nur kurz angerissen wurde, ist die relationale Interpretation von Typkonstruktoren.
%Für den Listentypkonstruktor wurde eine Formel gegeben, mit der eine Relation in den Listenkontext geliftet wird.
%Ähnlich kann man auch bei anderen Typen vorgehen, beispielsweise $Maybe$.

%Was aber völlig ignoriert wurde ist die Tatsache, dass man in Haskell auch über Typvariablen allquantifizieren kann, die ihrerseits
%nicht Platzhalter für speziellele Typen, sondern nur für Typkonstruktoren sind. In der Einleitung wurde bereits die Funktion $fmap$
%als Beispiel angegeben, die die folgende Typsignatur besitzt.
%Hier noch einmal das Beispiel aus der Einleitung:

\begin{minted}{haskell}
fmap :: Functor f => (a -> b) -> f a -> f b
\end{minted}

Die Variable $f$ wird über den Kontext auf die Typklasse \texttt{Functor} eingeschränkt. Letztere ist von der Sorte $* \rightarrow *$,
es handelt sich also um einen Typkonstruktor, der einen Typ auf einen neuen Typ abbildet.
%Es wird angegeben, dass $f$ eine Variable der Typklasse Functor ist. Functor ist von der \textit{Sorte} $* \rightarrow *$,
%das heißt es handelt sich um einen Typkonstruktor, der einen Typ auf einen neuen Typ abbildet.
Daher ist es in der Typsignatur legitim, diese Variable auf Typparameter anzuwenden, in diesem Beispiel also in $f\ a$ und $f\ b$.
Zwei Dinge müssen zum bisherigen Ansatz hinzugefügt werden: Allquantifizierung über Typkonstruktorvariablen muss separat betrachtet werden gegenüber Allquantifizierung über gewöhnlichen Typvariablen,
und Klasseneinschränkungen müssen beachtet werden, im obigen Beispiel \texttt{Functor\ f}.

Die Allquantifizierung über Typkonstruktorvariablen funktioniert an sich ähnlich wie die Allquantifizierung über gewöhnliche
Typvariablen. Statt als beliebige Relationen über beliebig gewählten Typen interpretiert man freie Typkonstruktorvariablen als
Funktionen über beliebigen Typkonstruktoren $k_1, k_2$, die eine Relation auf eine neue abbilden, indem sie die Typkonstruktoren
auf die Typmengen der Relation anwenden.
%die die Typmengen der Relation jeweils auf Typmengen abbildet,
%die durch Anwenden eines beliebigen
% mit beliebig gewählten Typkonstruktoren \cite{voigtlander}.

Es bietet sich an, an einem Beispiel zu zeigen, wie eine solche Relationsfunktion aussehen kann. Die folgende Formel zeigt eine
Funktion $\mathcal{F} : Maybe \Leftrightarrow []$, die eine Relation $\mathcal{R}$ auf eine neue Relation
$\mathcal{F}~\mathcal{R}$ abbildet.

\begin{align*}
\mathcal{F}~\mathcal{R} = \{ (Nothing, []) \} \cup \{(Just\ a, [b]) | (a, b) \in \mathcal{R}\}
\end{align*}

Diese Relation hat Ähnlichkeiten mit den Relationen, die für Basistypkonstruktoren wie Listen oder $Maybe$ konstruiert
werden.
%Tatsächlich ist die bereits eingeführte
%Relationskonstruktion für Listentypkonstruktoren bereits eine zulässige Relationsfunktion $\mathcal{F} : [] \Leftrightarrow []$, die
%eingesetzt werden kann \todo{eingesetzt werden kann?}.
Das Besondere an Typkonstruktorvariablen ist eben, dass man eine Aussage über \textit{alle} Relationsfunktionen trifft,
die infrage kommen.
Und es kommen nicht alle Funktionen infrage. Im obigen Beispiel wird die Typkonstruktorvariable auf die Typkonstruktorklasse
\texttt{Functor} eingeschränkt, deren Deklaration wie folgt aussieht.
%Diese Klasse definiert eine Funktion \texttt{fmap}, wie der folgenden Deklaration zu entnehmen ist.
%Dazu kommt noch die Beschränkung auf bestimmte Klassen. Hierzu bietet es sich an, die Funktion $fmap$ im Zusammenhang der
%Typklasse \texttt{Functor} zu betrachten.
%In einer Klassendefinition legt man Typparameter sowie
%Klassenfunktionen fest. Als Beispiel bietet sich die Klassendefinition von Functor an, hier beschränkt auf die interessante Funktion
%$fmap$:

\begin{minted}{haskell}
class Functor f where
  fmap :: (a -> b) -> f a -> f b
\end{minted}

Wie man sieht, hat die Klasse \texttt{Functor} einen Typparameter $f$ und definiert die Typsignatur zu $fmap$. Stößt man jetzt in
einer Typsignatur auf eine Klassenbeschränkung wie $Functor f$,
muss man die Allquantifizierung über Typkonstruktoren weiter einschränken.

% % % % % % % % BIS HIERHIN KONTROLLIERT % % % % % % % % % % % % % % %

Zum einen dürfen die resultierenden Relationen natürlich nur auf Typen definiert sein, für die Instanzen der entsprechenden
Klasse deklariert sind, in diesem Beispiel also nur Funktoren.
Zum anderen muss man aber auch fordern, dass Parametrizität bei Verwendung dieser Typen erhalten bleibt,
das heißt die Typen der einzelnen Klassenfunktionen müssen ihrerseits mit sich selbst verwandt sind bezüglich ihrer konstruierten Relation, wenn man für
die Typkonstruktorvariable die Funktion $\mathcal{F}$ einsetzt.
%Es muss sichergestellt werden, dass Parametrizität auch weiterhin gilt, wenn die Klassenfunktionen der entsprechenden Klasse,
%instanziiert auf den jeweiligen Typkonstruktor, angewandt werden. Und damit das gilt, muss man davon ausgehen können, dass für die
%Klassenfunktionen ihrerseits Parametrizität gilt, wenn mn 

%Das Ganze wird klarer, wenn man es an einem Beispiel verdeutlicht. Sei $\mathcal{A}(\mathcal{X})$ wieder eine Typrelation, die von
%einer Funktion auf Relationen $\mathcal{G}$ abhängt, und sei $C$ eine Typklasse.
%Dann definiert man die Allquantifizierung über Typkonstruktorvariablen wie folgt als Funktion auf Relationen.

Formal wird eine Allquantifizierung über Typkonstruktorvariablen in eine Relationsfunktion statt in eine Relation überführt. Die
zu überführende Typsignatur ist dabei von der folgenden Art.

\begin{minted}{haskell}
f :: C t => A(t)
\end{minted}

Hierbei soll \texttt{A(t)} ein Typausdruck sein, der die Typkonstruktorvariable \texttt{t} enthält. Man überführt diese Signatur wieder
wie üblich in eine entsprechende Relationaldarstellung $\forall^{\{C\}} \mathcal{T} . \mathcal{A}(\mathcal{T})$, wobei $\mathcal{A}$
die Typrelation zu \texttt{A} ist, abhängig von einer Funktion auf Relationen $\mathcal{T}$. Die Relationskonstruktion ist
dabei wie folgt definiert, wobei es es sich hier genau genommen um die Konstruktion einer Funktion auf Relationen handelt.

%Die semantische Aktion für die
%Allquantifizierung über Typkonstruktorvariablen sieht nun wie folgt aus.

\begin{align*}
& (x, x') \in \forall^{\{C\}} \mathcal{T} . \mathcal{A}(\mathcal{T}) \\
\Leftrightarrow ~& \forall k_1, k_2~\text{Typkonstruktoren für C, die C einhalten}\\
& \hphantom{\forall} \forall \mathcal{F} : k_1 \Leftrightarrow k_2 \\
& \hphantom{\forall \forall} (x_{k_1}, x'_{k_2}) \in \mathcal{A}(\mathcal{F})
\end{align*}

%Die Funktion wird also so konstriert, dass jede Relation auf eine Relation abgebildet wird, in der jeweils zwei Intanziierungen der
%für die jede Klassenfunktion bezüglich ihrer Typrelation mit sich selbst verwandt ist. Für unser Beispiel bedeutet das, es werden nur
%Funktionen $\mathcal{F} : k_1 \Leftrightarrow k_2$ betrachtet, für die die folgende Aussage gilt.
Es wird also über alle Typkonstruktoren und über alle Funktionen quantifiziert, die Relationen auf Relationen abbilden, wobei die
ursprünglichen Typmengen auf die Typmengen abgebildet werden, die durch Anwendung der Typkonstruktoren entstehen.
Die Beschränkung auf ``Typkonstruktoren für C, die C einhalten'' ist die bereits angesprochene Einschränkung auf diejenigen Funktionen, die für die
entsprechende Typklasse überhaupt infrage kommen. Man kann diese Einschränkung zusammenfassend durch die folgenden
beiden Kriterien beschreiben.

\begin{itemize}
\item Die entsprechende Funktion muss Relationen auf solche Relationen abbilden, die auf Typen definiert sind, für die es Instanzdeklarationen
für die Klasse gibt.
\item Die entsprechende Funktion muss Relationen auf solche Relationen abbilden, für die sämtliche Klassenfunktionen wiederum mit sich selbst
verwandt sind bezüglich ihrer jeweiligen Relationaldarstellung, wenn für die entsprechende Typkonstruktorvariable die Funktion
eingesetzt wird.
\end{itemize}

Um wieder auf das ursprüngliche Beispiel der \texttt{Functor}-Klasse zurückzukommen, ist im Folgenden die Bedingung gegeben,
die gelten muss für eine Funktion $\mathcal{F}$, damit diese die Klasse \texttt{Functor} einhält.

\begin{align*}
(fmap_{k_1}, fmap_{k_2}) \in \forall \mathcal{R} . ~\forall \mathcal{S} . (\mathcal{R} \rightarrow \mathcal{S}) \rightarrow \mathcal{F} \mathcal{R}
\rightarrow \mathcal{F} \mathcal{S}
\end{align*}

%Die Anwendung von Typkonstruktorfunktionen auf Typrelationen ist nun nichts anderes als wiederum ein Lifting dieser
%Relation - mit dem Unterschied, dass wir erstmal keine genauen Aussagen über dieses Lifting treffen können.

Wird nun eine Typkonstruktorvariable auf einen Typ angewandt, handelt es sich nicht um eine relationale Aktion, die Anwendung findet.
Letztere wäre ja um Konstruktion von Relationen aus Typen, basierend auf existierenden Relationen.
Typkonstruktorvariablen sind aber keine Relationen, es handelt sich um Funktionen -- und die Applikation dieser Funktionen auf
Typrelationen ist auch tatsächlich einfach eine Funktionsanwendung, deren Ergebnis wieder eine Relation ist.

Es ist noch anzumerken, dass eine entsprechende Methode natürlich auch für Typ\-klas\-sen ohne Typparameter möglich ist. Der
Unterschied zu Typkonstruktorklassen ist der, dass bei letzteren die Parametrizitätsaussagen der einzelnen Klassenfunktionen
bezüglich einer Relationsfunktion $\mathcal{F}$ gelten müssen, damit diese zulässig ist.
Bei simplen Typklassen muss einfach nur jede einzelne Parametrizitätsaussage für sich selbst gelten.
%,
%die sogar in der Bibliothek \textit{free-theorems} schon Anwendung findet. Der wichtige Schritt von simplen Typklassen
%zu Typkonstruktorklassen ist das Einsetzen der Relationskonstruktion für Typkonstruktorvariablen in die Parametrizitätsaussagen
%der Klassenfunktionen. \todo{das könnte man sicherlich auhc noch ein bisschen deutlicher machen}

%Die Erweiterung um Typkonstruktorvariablen ist also alles in allem nicht besonders komplex oder tiefgreifend, sie betrifft aber sämtliche
%Teile der zu erweiternden Bibliothek. Bevor jedoch die Implementierung betrachtet wird, soll zunächst noch einmal an
%einem Beispiel gezeigt werden, wozu man freie Theoreme -- insbesondere erweitert auf Typkonstruktorklassen -- verwenden kann.


%Eine Frage, die sich nun stellt, ist: Inwiefern kann man dann überhaupt mit diesen Relationsfunktionen arbeiten? An sich ist ja nur
%bekannt, dass sie Typrelationen auf andere Typrelationen abbilden. Mit der Klassenbeschränkung ist aber zumindest ein
%Anhaltspunkt gegeben. So kann man im Fall der $Functor$ Klasse beispielsweise davon ausgehen, dass es in irgendeiner
%Art und Weise möglich sein muss, den ``Inhalt'' des Functors zu manipulieren - eine Art ``natürliches'' $map$ 
%\todo{Quelle? Beweis?}, das im folgenden $map_F$ genannt wird.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Anwendung}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\label{sec:freie-theoreme-anwendung}

%In den vorangehenden Abschnitten wurde beschrieben, wie freie Theoreme hergeleitet werden. Um zu zeigen, welchen
%Nutzen diese Technik hat und was man damit herleiten kann, werden in diesem Abschnitt einige Beispiele gegeben,
%in denen freie Theoreme eine Rolle spielen.

In den vorangegangenen Abschnitten wurde beschrieben, wie freie Theoreme hergeleitet werden. Das Vorgehen wurde am einfachen
Beispiel $f :: [a] \rightarrow [a]$ verdeutlicht. Dieses Beispiel beschreibt die grundlegende Technik zwar, die resultierende
Aussage an sich ist aber relativ simpel und darüber hinaus kaum interessant.
In diesem Abschnitt sollen zwei Beispiele betrachtet werden, die ein wenig komplexer und auch etwas interessanter sind. Vor
allem aber verwenden sie Typkonstruktorklassen, es kann also an Beispielen gezeigt werden, wie sich die Herleitung
von freien Theoremen gestaltet, wenn Typkonstruktorvariablen eine Rolle spielen.

%Dieses Beispiel zeigt zwar, wie die Technik funktioniert, ist an sich aber nicht wirklich
%weltbewegend. In diesem Abschnitt sollen nun einige interessantere Anwendungsbeispiele aufgezeigt werden.

In Haskell ist es gebräuchliche Praxis, für Datentypen oder Typklassen zusätzliche Einschränkungen zu definieren, die nicht durch
die Implementierung sichergestellt werden. Stattdessen liegt es am Anwender, diese Einschränkungen einzuhalten, und es hindert
ihn nichts daran, diese Gesetze zu missachten. Ein prominentes Beispiel ist die Klasse \texttt{Functor}, die die Funktion
\texttt{fmap} definiert. Für \texttt{fmap} werden die folgenden Gesetze gefordert.

%\begin{minted}{haskell}
%return a >>= k  =  k a
%m >>= return  =  m
%m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
%\end{minted}

%Auch für die Functor-Klasse sind solche Gesetze definiert:

\begin{minted}{haskell}
fmap id      = id
fmap (p . q) = (fmap p) . (fmap q)
\end{minted}

%Eine interessante Besonderheit der Functor-Gesetze ist, dass in Haskell tatsächlich nur das erste Gesetz gelten muss. Gilt es, dann kann
%man das zweite Gesetz daraus unter Zuhilfenahme der freien Theoreme folgern. Dieser Beweis basiert auf dem Ansatz in \cite{fmap}.

Es wäre nun interessant zu betrachten, welche Aussagen zu dieser Funktion das freie Theorem offenbart. Tatsächlich lässt sich
nach Kmett \cite{fmap} zeigen, wie man mithilfe des freien Theorems beweisen
kann, dass das zweite Gesetz in Haskell immer gelten muss, wenn das erste Gesetz gilt.

Dieser Beweis soll an dieser Stelle nicht wiedergegeben werden, weil er vor allem zu weit über die Thematik von freien Theoremen
hinausgeht, aber es ist sinnvoll zu zeigen, wie man das freie Theorem für die Funktion \texttt{fmap} herleitet.

%Wir beginnen mit der Herleitung des freien Theorems, wobei zu beachten ist, dass dieses Mal eine Typkonstruktorvariable auftritt. Im
Wie bereits erwähnt, hat \texttt{fmap} die folgende Typsignatur.

\begin{minted}{haskell}
fmap :: Functor f => (a -> b) -> f a -> f b
\end{minted}

Die Besonderheit an dieser Signatur ist die auftretende Typkonstruktorvariable $f$. Doch nicht minder interessant ist die Tatsache, dass
eine Funktion als Parameter übergeben wird -- dieser Fall wurde in dieser Arbeit bisher noch nicht explizit an einem Beispiel erklärt.
Im Folgenden ist zu sehen, wie das Parametrizitätstheorem angewandt wird und Schritt für Schritt die jeweiligen relationalen Aktionen
eingesetzt werden, wobei $(* \rightarrow *)$ die Menge aller Typkonstruktoren der Sorte $* \rightarrow *$ sei.
%auch eine Typkonstruktorvariable vorkommt.

%An diesen Functor-Gesetzen ist interessant, dass tatsächlich nur das erste Gesetz gelten muss - das zweite folgt dann automatisch
%aus dem freien Theorem von $fmap$, wird uns also abermals ``geschenkt''. Um das zu zeigen, folgen wir wieder der bereits bekannten Vorgehensweise, dieses Mal erweitert um Typkonstruktorvariablen:

\begin{align*}
&(fmap, fmap) \in \forall \mathcal{F} .~ \forall \mathcal{R} .~ \forall \mathcal{S} .~ (\mathcal{R} \rightarrow \mathcal{S})
\rightarrow \mathcal{F} \mathcal{R} \rightarrow \mathcal{F} \mathcal{S} \\
&\\
\Leftrightarrow ~&
\forall k1, k2 \in (* \rightarrow *), \mathcal{K} : k_1 \Leftrightarrow k_2, \mathcal{K}~\text{beachtet Functor} \\
& \hphantom{\forall} (fmap_{k1}, fmap_{k2}) \in \forall \mathcal{R} .~ \forall \mathcal{S} .~ (\mathcal{R} \rightarrow \mathcal{S}) \rightarrow
\mathcal{K} \mathcal{R} \rightarrow \mathcal{K} \mathcal{S} \\
&\\
\Leftrightarrow ~&
\forall k1, k2 \in (* \rightarrow *), \mathcal{K} : k_1 \Leftrightarrow k_2, \mathcal{K}~\text{beachtet Functor} \\
& \hphantom{\forall} \forall A, A' \in Typen, \mathcal{A} : A \Leftrightarrow A' \\
& \hphantom{\forall \forall} \forall B, B' \in Typen, \mathcal{B} : B \Leftrightarrow B' \\
& \hphantom{\forall \forall \forall} (fmap_{k1 A B}, fmap_{k2 A' B'}) \in (\mathcal{A} \rightarrow \mathcal{B}) \rightarrow
\mathcal{K} \mathcal{A} \rightarrow \mathcal{K} \mathcal{B} \\
&\\
\Leftrightarrow ~&
\forall k1, k2 \in (* \rightarrow *), \mathcal{K} : k_1 \Leftrightarrow k_2, \mathcal{K}~\text{beachtet Functor} \\
& \hphantom{\forall} \forall A, A' \in Typen, \mathcal{A} : A \Leftrightarrow A' \\
& \hphantom{\forall \forall} \forall B, B' \in Typen, \mathcal{B} : B \Leftrightarrow B' \\
& \hphantom{\forall \forall \forall} \forall (g_1, g_2) \in (\mathcal{A} \rightarrow \mathcal{B}) \\
& \hphantom{\forall \forall \forall \forall} (fmap_{k1 A B}\ g_1, fmap_{k2 A' B'}\ g_2) \in \mathcal{K} \mathcal{A} \rightarrow \mathcal{K} \mathcal{B} \\
\end{align*}

Da der erste Parameter von $fmap$ eine Funktion ist, werden auch Elemente aus dieser Funktionstyprelation allquantifiziert, d.h.
$\forall (g, g') \in (\mathcal{A} \rightarrow \mathcal{B})$. Auch an dieser Stelle kann man die Definition des Funktionstypkonstruktors
einsetzen, also $(g, g') \in (\mathcal{A} \rightarrow \mathcal{B})$ genau dann, wenn $\forall (x, x') \in \mathcal{A}: (g\ x, g'\ x')
\in \mathcal{B})$. Die Aussage lässt sich also wie folgt weiter umformen.

%Diese Allquantifizierung ist äquivalent zu
%$\forall (g, g'): (g, g') \in (\mathcal{A} \rightarrow \mathcal{B})$ und somit auch zu $\forall (g, g') \in
%(\mathcal{A} \rightarrow \mathcal{B}): (\forall (x, x') \in \mathcal{A}: (g x, g' x') \in \mathcal{B})$, wenn man die Definition für
%$\mathcal{A} \rightarrow \mathcal{B}$ anwendet. \todo{Hier stimmt was nicht, nochmal korrigieren}Man kommt also auf:

\begin{align*}
&\forall k1, k2 \in (* \rightarrow *), \mathcal{K} : k_1 \Leftrightarrow k_2, \mathcal{K}~\text{beachtet Functor} \\
&\hphantom{\forall} \forall A, A' \in Typen, \mathcal{A} : A \Leftrightarrow A' \\
&\hphantom{\forall \forall} \forall B, B' \in Typen, \mathcal{B} : B \Leftrightarrow B' \\
&\hphantom{\forall \forall \forall} \forall g_1 : A \rightarrow B, g_2 : A' \rightarrow B' \\
&\hphantom{\forall \forall \forall \forall} (\forall (x, x') \in \mathcal{A}. (g_1\ x, g_2\ x') \in \mathcal{B})\\
&\hphantom{\forall \forall \forall \forall (} \Rightarrow (fmap_{k1 A B}\ g_1, fmap_{k2 A' B'}\ g_2) \in \mathcal{K} \mathcal{A} \rightarrow \mathcal{K} \mathcal{B} \\
&\\
\Leftrightarrow~ &\forall k1, k2 \in (* \rightarrow *), \mathcal{K} : k_1 \Leftrightarrow k_2, \mathcal{K}~\text{beachtet Functor} \\
&\hphantom{\forall} \forall A, A' \in Typen, \mathcal{A} : A \Leftrightarrow A' \\
&\hphantom{\forall \forall} \forall B, B' \in Typen, \mathcal{B} : B \Leftrightarrow B' \\
&\hphantom{\forall \forall \forall} \forall g_1 : A \rightarrow B, g_2 : A' \rightarrow B' \\
&\hphantom{\forall \forall \forall \forall} (\forall (x, x') \in \mathcal{A}.~ (g_1\ x, g_2\ x') \in \mathcal{B})\\
&\hphantom{\forall \forall \forall \forall (} \Rightarrow \forall (y, y') \in \mathcal{K} \mathcal{A} \\
&\hphantom{\forall \forall \forall \forall ( \Rightarrow \forall} (fmap_{k1 A B}\ g_1\ y, fmap_{k2 A' B'}\ g_2\ y') \in \mathcal{K} \mathcal{B}\\
\end{align*}

%TODO: den rest nicht, vorher wurde ja gesagt, dass das nicht geht, warum sollte man es dann jetzt machen können?

An dieser Stelle ist es noch möglich, die Relationen $\mathcal{A}$ und $\mathcal{B}$ auf Funktionen zu spezialisieren. Wir werden
feststellen, dass dies bei auftretenden Typkonstruktorvariablen leider oftmals keine Vereinfachung bringt, da Typkonstruktorvariablen
über beliebige Typkonstruktoren allquantifiziert werden und deshalb nichts Genaues über sie bekannt ist.

Im vorangegangenen Abschnitt wurde bereits erläutert, dass man bei der Spezialisierung zu einigen gelifteten Datentypen
spezielle Funktionen einführen kann, um die spezialisierten Funktionen in einen entsprechenden Kontext zu liften, beispielsweise
durch Verwenden der Funktion $map$, wenn eine Relation durch den Listentypkonstruktor in den Listenkontext geliftet wird.
%Es wurde bereits vorher
%erläutert, dass man in diesem Schritt bei bestimmten Datentypen spezielle Funktionen einführen kann, um die spezialisierten
%Funktionen in einen entsprechenden Kontext zu liften. Als Beispiel war die Funktion $map$ gegeben, die eingefügt wird,
%wenn eine Relation durch den Listentypkonstruktor in den Listenkontext geliftet wird.

Es wäre wünschenswert, an dieser Stelle ebenfalls eine solche Funktion einzufügen. Im betrachteten Beispiel handelt es sich um die
\texttt{Functor}-Klasse, von der wir wissen, dass sie eine Funktion \texttt{fmap} enthält, die den Inhalt des entsprechenden
\texttt{Functor}-Datentyps manipuliert, und man könnte argumentieren, dass sie für diesen Zweck geeignet ist -- zumindest, wenn sie
korrekt implementiert wurde und die \texttt{Functor}-Gesetze einhält. Da aber der allgemeine Fall betrachtet werden soll, in dem
eine solche Funktion nicht unbedingt gegeben ist, beschränken wir uns hier darauf,
%\todo{Hier vielleicht eine Anmerkung, dass nur das erste Gesetz gelten muss und Verweis auf url}
%Man könnte an dieser Stelle argumentieren, dass die \texttt{Functor-Klasse eine solche Funktion also bereitstellt, doch im allgemeinen
%Fall ist eine solche Funktion nicht zwingend gegeben.
%Wir beschränken uns also darauf,
die Relationsfunktion $\mathcal{K}$ auf
die entsprechende Funktion anzuwenden. Da sich die Funktion als Relation auffassen lässt, können wir daraus auch wieder
eine Relation generieren.

% TODO: wahrscheinlich eher hier ein bisschen mehr dazu schreiben, statt später, wenn es um die implementierung geht.

%, und wir bekommen das
%folgende Theorem:
%
\begin{align*}
&\forall k1, k2 \in (* \rightarrow *), \mathcal{K} : k_1 \Leftrightarrow k_2, \mathcal{K}~\text{beachtet Functor} \\
&\hphantom{\forall} \forall a : A \rightarrow A' \\
&\hphantom{\forall \forall} \forall b : B \rightarrow B' \\
&\hphantom{\forall \forall \forall} \forall g_1 : A \rightarrow B\\
& \hphantom{\forall \forall \forall \forall} \forall g_2 : A' \rightarrow B' \\
& \hphantom{\forall \forall \forall \forall \forall} (\forall x \in A : b\ (g_1\ x) = g_2 (a x))\\
& \hphantom{\forall \forall \forall \forall \forall} \Rightarrow \forall y \in k_1\ A\\
&\hphantom{\forall \forall \forall \forall ( \forall \Rightarrow \forall} (fmap_{k1 A B}\ g_1\ y, fmap_{k2 A' B'}\ g_2) \in \mathcal{K} b
\end{align*}

Es ist natürlich schade, dass die Spezialisierung auf Funktionen durch die Anwendung der Relationsfunktion gewissermaßen wieder
rückgängig gemacht wird.
Das macht die Spezialisierung auf Funktionen natürlich nicht hinfällig, auf der linken Seite der entstandenen Implikation bietet die
Spezialisierung einen Vorteil bei der Lesbarkeit.

Somit haben wir also das freie Theorem für \texttt{fmap} hergeleitet. Es zeigt sich, dass auch mit Typkonstruktorvariablen ganz normal
gearbeitet werden kann. Durch das Auftreten der Funktion als Parameter ist auch gut zu sehen, wie eine solche Funktion
zu einer Implikation führt, da für Elemente der entsprechenden Relation wiederum die Relationskonstruktion aus dem Funktionstyp
gilt.

Nicht zu vergessen ist, was sich hinter der Einschränkung ``$\mathcal{K}$ beachtet Functor'' verbirgt: Es muss Parametrizität gelten
für alle Klassenfunktionen von \texttt{Functor}, wenn für die Typkonstruktorvariable $\mathcal{K}$ eingesetzt wird (wie es zu Beginn
des Abschnitts bereits erläutert wurde).
%
%$map_F$ ist hierbei die Funktion, die eine beliebige Funktion in den $\mathcal{K}$-Kontext liftet.
%Anders ausgedrückt sagt dieses Theorem also, für beliebige Funktionen $a, b, g_1, g_2$ gilt, falls $b . g_1 = g_2 . a$, die folgende Aussage
%(die Typinstanzierungen werden hier der Übersichtlichkeit halber weggelassen):
%
%\begin{align*}
%(map_F\ b)\ .\ (fmap\ g_1\ y) = (fmap\ g_2)\ .\ (map_F\ a\ y)
%\end{align*}
%
%Der Punktoperator ist hierbei die Funktionsverkettung. Nun muss man noch zeigen dass $fmap\ f = map_F\ f$, was aus $fmap\ id = id$ (also dem ersten geforderten Gesetz) folgt.
%
%\begin{align}
%& fmap\ f \nonumber \\
%= & map_F\ id\ .\ fmap\ f \nonumber \\
%= & fmap\ id\ .\ map_F\ f \label{eq:freetheorem} \\
%= & map_F\ f \nonumber
%\end{align}
%
%In Zeile (\ref{eq:freetheorem}) wird das freie Theorem angewandt mit $g = k = id$ und $h = f$. \todo{korrekte bezeichnungen!} Damit ist gezeigt, dass $fmap = map_F$ gilt. Da laut dem ersten Funktorgesetz die Aussage $fmap\ id = id$ gilt, lässt sich Folgendes zeigen.
%
%\begin{align*}
%& fmap\ f\ .\ fmap \\
%= & map_F\ .\ fmap\ g \\
%= & fmap\ id\ .\ map_F\ (f\ .\ g) \\
%= & map_F\ (f\ .\ g) \\
%= & fmap (f\ .\ g)
%\end{align*}
%
%Es reicht also aus zu fordern, dass für Funktoren $fmap\ id = id$ gilt. Wie bereits erwähnt, werden diese Gesetze nicht
%erzwungen, auch die Gesetze, die für die Monaden-Klasse formuliert werden, können theoretisch missachtet werden.
%Mathematisch gesehen haben sie den Namen zwar erst verdient, wenn diese Gesetze gelten, doch sprachtechnisch gelten keine
%Einschränkungen. Geht man davon aus, dass sie erfüllt sind, lassen sich jedoch noch zusätzliche Aussagen treffen, die ohne diese
%Gesetze nicht möglich wären, wie zum Teil in \cite{voigtlander} untersucht wird.

% % % % % % % % % %

In der Arbeit, in der Voigtländer die hier verwendete Interpretation von Typkonstruktorvariablen in freien Theoremen
einführt \cite{voigtlander}, nutzt er diese Erweiterung der freien Theoreme, um einige Überlegungen insbesondere zu Monaden
anzustellen. Es soll nachfolgend eine dieser Überlegungen dargestellt werden, um ein weiteres Beispiel für den Einsatz von
freien Theoremen, insbesondere mit der Erweiterung um Typkonstruktorvariablen, vorzuführen.
Der folgende Code zeigt, wie die Monadenklasse definiert ist.

\begin{minted}{haskell}
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a
\end{minted}

Tatsächlich gibt es noch weitere Funktionen \texttt{>>} und \texttt{fail}, diese spielen jedoch in diesem Fall keine Rolle und besitzen
darüber hinaus Standardimplementierungen. Wie auch für Funktoren gibt es in Haskell einige -- von Haskell nicht erzwungene -- Gesetze,
die für Monadeninstanzen gelten sollten. Diese sind wie folgt definiert.

\begin{minted}{haskell}
return a >>= k  =  k a
m >>= return  =  m
m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
\end{minted}

%Im Folgenden sollen einige Überlegungen speziell zu Monaden angestellt werden, wie sie in \cite{voigtlander}
%eingeführt werden.

Ein monadischer Wert heißt \textit{rein}, wenn er mit keinerlei monadischem Effekt versehen ist. Ein einfaches Beispiel für monadische
Effekte liefert zum Beispiel die \texttt{IO}-Monade, mit deren Hilfe Seiteneffekte wie Ein- und Ausgabe umgesetzt werden. So
stellt ein Ausdruck mit dem Typ \texttt{IO\ a} eine Berechnung dar, bei deren Ausführung es zu Ein- und Ausgaben kommen kann, aber
nicht muss.

Der Ausdruck \texttt{getLine} vom Typ \texttt{IO String} ist ein Beispiel für einen solchen effektbehafteten monadischen Ausdruck, da
er nicht nur eine Zeichenkette enthält, sondern auch einen Seiteneffekt, der das Einlesen dieser Zeichenkette von der
Standardeingabe verursacht.
Der folgende Ausdruck wiederum ist ein Beispiel für einen reinen monadischen Wert, der keinen monadischen
Effekt enthält.

\begin{minted}{haskell}
return "Zeichenkette"
\end{minted}

Man kann einen reinen Wert ansehen als den Wert, der von der \texttt{return}-Funktion der jeweiligen Monadeninstanz
bzw. einer semantisch äquivalenten Funktion geliefert wird. Betrachten wir die folgende Funktion.

\begin{minted}{haskell}
f :: Monad m => [m Int] -> m Int
\end{minted}

Eine Erkenntnis von Voigtländer ist nun, dass man im Fall, dass die Eingabeliste nur reine Werte beinhaltet, davon ausgehen
kann, dass das Ergebnis auch rein ist, sofern die Monade das erste Monadengesetz erfüllt: $return_k\ a\ {>>=}_k\ k = k\ a$. Man argumentiert hier genauso wie bei polymorphen Funktionen: Da die Funktion über
beliebige Monaden $m$ definiert ist, hat die Funktion keine Kenntnis über die jeweilige Monade, die genutzt wird.
Sie kann dementsprechend keine monadenspezifischen Effekte einführen; nur bereits vorhandene
Effekte können gegebenenfalls beibehalten werden.

\begin{figure}[ht]
\centering
\includegraphics[height=100px]{purity-preservation}
\caption{Erhaltung von reinen Ausdrücken}
\label{fig:purity-preservation}
\end{figure}

In einer Formel ausgedrückt heißt das, dass das folgende Theorem gilt.

\begin{mytheorem}
Sei $f :: Monad\ \mu \Rightarrow [\mu\ Int] \rightarrow \mu\ Int$, sei $\kappa$ eine Instanz von Monad, für die Monadengesetz (1) gilt.
Sei $l :: [\kappa\ Int]$. Wenn jedes Element in l ein Bild von $return_{\kappa}$ ist, dann ist auch $f_{\kappa}\ l$ ein Bild von $return_{\kappa}$.
\end{mytheorem}

Um zu zeigen, dass dieses Theorem gilt, leiten wir zunächst das freie Theorem zur Funktion $f$ her. Da an dieser Stelle klar sein
sollte, wie das Prinzip des schrittweisen Abrollens funktioniert, wird hier direkt das resultierende Theorem angegeben.

\begin{align*}
& \forall k_1, k_2 \in (* \rightarrow *), \mathcal{M} : k_1 \Leftrightarrow k_2, \mathcal{M}~\text{beachtet Monad} \\
& \hphantom{\forall} \forall (x, y) \in [\mathcal{M}\ id_{Int}] \\
& \hphantom{\forall \forall} (f_{k_1}\ x, f_{k_2}\ y) \in \mathcal{M}\ id_{Int}
\end{align*}

Wir möchten nun zeigen, dass das Ergebnis von $f_{\kappa}$ für eine beliebige Liste von $return_{\kappa}$-Bildern selbst ein
$return_{\kappa}$-Bild ist. Hierzu betrachten wir eine beliebige Liste $l' :: [Int]$. Wenden wir auf jedes Listenelement von $l'$ die
Funktion $return_{\kappa}$ an, erhalten wir folglich eine solche Liste von $return_{\kappa}$-Bildern. Anders schreiben lässt
sich das mithilfe der $map$-Funktion als $map\ return_{\kappa}\ l'$.

Nun müssen wir beweisen, dass man durch Anwenden von $f_{\kappa}$ auf diese Liste einen Ausdruck erhält, der einem
$return_{\kappa}$, angewandt auf einen Ausdruck, entspricht. Um dies zu tun, führen wir zunächst einen neuen Typ ein und deklarieren
für diesen eine Monadeninstanz.

\begin{minted}{haskell}
newtype Id a = Id { unId :: a }

instance Monad Id where
   return a = Id a
   Id a >>= k = k a
\end{minted}

Diese Monade reicht also einfach nur den internen Wert weiter, \texttt{return} setzt diesen Wert. Sonstige Effekte
sind nicht vorhanden.
Es ist nun zu zeigen, dass für jede Liste $l' :: [Int]$ Folgendes gilt.

\begin{align*}
f_k (map\ return_{\kappa}\ l') = return_{\kappa} (unId (f_{Id} (map\ Id\ l')))
\end{align*}

Dass dies die Behauptung ist, die wir beweisen wollen, ist nicht unbedingt auf den ersten Blick klar. Auf der rechten
Seite der Gleichung sieht man den Ausdruck $map\ Id\ l'$. Es wird also der Konstrktor $Id$ auf jedes Element der Liste $l'$
angewandt. Auf den resultierenden Ausdruck wird die Funktion $f_{Id}$ angewandt, also $f$, instanziiert auf den
Typkonstruktor $Id$. Das ist möglich, da $Id$ eine Instanz der Klasse \texttt{Monad} ist. Auf den daraus entstehenden Ausdruck
wird \texttt{unId} aufgerufen, was uns wieder den internen Wert der \texttt{Id}-Monade gibt. Schließlich wird darauf die
Funktion $return_{\kappa}$ angewandt.

Das Problem ist ja, dass wir für eine beliebige Monade $\kappa$ keine Möglichkeit haben, den reinen Wert zurückzuholen. Wir können
aber eine eigene Monade definieren und das freie Theorem geschickt nutzen, um eine Beziehung zwischen der $\kappa$-Monade
und der $Id$-Monade zu erhalten.

Wir definieren eine Funktion auf Relationen $\mathcal{F} : \kappa \Leftrightarrow Id$ wie folgt.

\begin{align*}
\mathcal{F} \mathcal{R} = return_{\kappa}^{-1} ; \mathcal{R} ; Id
\end{align*}

Jetzt zeigen wir, dass diese Funktion die Klasse \texttt{Monad} beachtet\footnote{Voigtländer nennt eine Funktion, die die Klasse \texttt{Monad} beachtet, auch eine Monaden-Aktion \cite{voigtlander}}. Es ist also zunächst Folgendes für die $return$-Funktion zu zeigen.

\begin{align*}
(return_{\kappa}, return_{Id}) \in \forall \mathcal{R}. \mathcal{R} \rightarrow \mathcal{F} \mathcal{R}
\end{align*}

Rollt man diese Gleichung ab, erhält man die folgende Aussage, die zu zeigen ist.

\begin{align*}
& \forall T_1, T_2 \in Typen, \mathcal{R} : T_1 \Leftrightarrow T_2 \\
& \hphantom{\forall} \forall (a, b) \in \mathcal{R} \\
& \hphantom{\forall \forall} (return_{\kappa}\ a, return_{Id}\ b) \in \mathcal{F}\ \mathcal{R}
\end{align*}

Setzt man das oben definierte $\mathcal{F}$ ein, sieht man, dass diese Aussage stimmt, da man wie folgt argumentieren kann.

Die Verkettung $return_{\kappa}^{-1} ; \mathcal{R} ; Id$ kann man ansehen als Einkapselung der Relation in die 
Monaden-Konstruktoren für $\kappa$ und $Id$: Zwei Werte sind bezüglich dieser Relation verwandt, wenn es
eine Möglichkeit gibt, den ersten Wert mit der inversen Relation zur Funktion $return_{\kappa}$ in einen puren Wert
umzuwandeln und es einen zu diesem puren Wert verwandten Wert in $\mathcal{R}$ gibt, der sich mithilfe von $Id$ wieder
in einen Wert des $Id$-Datentyps umwandeln lässt.

Es ist $return_{\kappa}^{-1}\ return_{\kappa}\ a = a$ und $a \in \mathcal{R}$. Da $Id$ der Konstruktor zum Datentyp $Id$
ist, der für beliebige Typen definiert ist, ist natürlich auch $(a, Id\ a) \in Id$, wenn man den Konstruktor $Id$ als Relation auffasst.
Und da $return_{Id}$ implementiert ist mit \texttt{return a = Id a}, gilt die folgende Aussage.

\begin{align*}
(return_{\kappa}\ a, return_{Id}\ b) = (return_{\kappa}\ a, Id\ b) \in return_{\kappa}^{-1} ; \mathcal{R} ; Id
\end{align*}

Ein wenig aufwendiger wird es, die Parametrizitätsaussage für die zweite Funktion zu zeigen.

\begin{align*}
& ((>>=_{\kappa}), (>>=_{Id})) \in \forall \mathcal{R}. \forall \mathcal{S}. \mathcal{F} \mathcal{R} \rightarrow
((\mathcal{R} \rightarrow \mathcal{F} \mathcal{S}) \rightarrow \mathcal{F} \mathcal{S}) \\
\Leftrightarrow ~& \forall T_1, T_2 \in Typen, \mathcal{R} : T_1 \Leftrightarrow T_2 \\
& \hphantom{\forall} \forall T_3, T_4 \in Typen, \mathcal{S} : T_3 \Leftrightarrow T_4 \\
& \hphantom{\forall \forall} \forall (a, b) \in \mathcal{F}\ \mathcal{R} \\
& \hphantom{\forall \forall \forall} \forall (k_1, k_2) \in \mathcal{R} \rightarrow \mathcal{F}\ \mathcal{S}\\
& \hphantom{\forall \forall \forall \forall} ((>>=)_{\kappa T_1 T_3}\ a\ k_1, (>>=)_{Id T_2 T_4}\ b\ k_2) \in \mathcal{F} \mathcal{S}\\
\Leftrightarrow ~& \forall T_1, T_2 \in Typen, \mathcal{R} : T_1 \Leftrightarrow T_2 \\
& \hphantom{\forall} \forall T_3, T_4 \in Typen, \mathcal{S} : T_3 \Leftrightarrow T_4 \\
& \hphantom{\forall \forall} \forall (a, b) \in return_{\kappa}^{-1}~;~\mathcal{R}~;~Id \\
& \hphantom{\forall \forall \forall} \forall (k_1, k_2) \in \mathcal{R} \rightarrow return_{\kappa}^{-1}~;~\mathcal{S}~;~Id\\
& \hphantom{\forall \forall \forall \forall} (a\ >>=_{\kappa T_1 T_3}\ k_1, b\ >>=_{Id T_2 T_4}\ k_2) \in return_{\kappa}^{-1}~;~\mathcal{S}~;~Id
\end{align*}

Wir betrachten also beliebige $\mathcal{R}$ und $(return_{\kappa}\ a, Id\ b) \in return_{\kappa}^{-1}~;~\mathcal{R}~;~Id$
(durch die Komposition mit $return_{\kappa}^{-1}$ und $Id$ können die Elemente von $\mathcal{F}$ nur von dieser Form sein).
Zudem seien $(k_1, k_2) \in \mathcal{R} \rightarrow \mathcal{F}\ \mathcal{S}$, was bedeutet, dass für alle $(x, y) \in \mathcal{R}$
gilt, dass $(k_1\ x, k_2\ y) \in return_{\kappa}^{-1}~;~\mathcal{S}~;~Id$.

Durch das erste Monadengesetz, \texttt{return a >>= k = k a}, gilt die folgende Aussage.

\begin{align*}
(return_{\kappa}\ a >>=_{\kappa} k_1, Id\ b >>=_{Id}\ k_2) = (k_1\ a, k_2\ b)
\end{align*}

Da $(k_1\ a, k_2\ b) \in return_{\kappa}^{-1}~;~\mathcal{S}~;~Id$, ist auch die Parametrizitätsaussage für die zweite Funktion
gezeigt. Somit sind beide Aussagen gezeigt und es gilt, dass $\mathcal{F}$ die Klasse \texttt{Monad} beachtet. Das heißt, dass
das freie Theorem zu $f$ für $\mathcal{F}$ gilt, sprich: $(f_{\kappa}, f_{Id}) \in [\mathcal{F}\ id_{Int}] \rightarrow \mathcal{F}\ 
id_{Int}$. Es gilt nun Folgendes.

\begin{align*}
& \mathcal{F}\ id_{Int} \\
=~& return_{\kappa}^{-1}~;~id_{Int}~;~Id \\
=~& return_{\kappa}^{-1}~;~Id \\
=~& return_{\kappa}^{-1}~;~unId^{-1} \\
=~& (return_{\kappa} \circ unId)^{-1}
\end{align*}

Das freie Theorem zu $f$ impliziert also die folgende Aussage, da $\mathcal{F}$ die Klasse \texttt{Monad} beachtet und man
die Relationen wieder zu Funktionen spezialisieren kann, und somit beweist die folgende Aussage die Behauptung.

\begin{align*}
& \forall (x, y) \in [(return_{\kappa} \circ unId)^{-1}] \\
& \hphantom{\forall} (f_{\kappa}\ x, f_{Id}\ y) \in (return_{\kappa} \circ unId)^{-1} \\
\Rightarrow~& \forall l' :: [Int] \\
& \hphantom{\forall} return_{\kappa} (unId (f_{Id}\ (map\ Id\ l'))) = f_{\kappa}\ (map\ return_{\kappa}\ l')
\end{align*}


%Ist nicht sichergestellt, dass sämtliche Elemente der Eingabeliste rein sind, kann man sich weiter überlegen, dass eine
%Möglichkeit zur Verfügung steht, mit der man den reinen Inhalt des monadischen Werts extrahieren kann - ähnlich wie
%die unsichere Funktion \texttt{unsafePerformIO}, die den reinen Wert aus einer IO-Monade extrahiert, nur eben für
%andere Monaden und sicher.
%Es ist ja vorstellbar, dass man nur am reinen Ergebnis einer Funktion $f$ interessiert ist, unabhängig von eventuellen anhaftenden
%monadischen Effekten. Tatsächlich kann man unter bestimmten Voraussetzungen zeigen, dass man beliebige Effekte in der 
%Eingabeliste ignorieren kann, wenn man nur am reinen Ergebnis interessiert ist.
%
%Sei $f :: Monad\ m \Rightarrow [m\ Int] \rightarrow m\ Int$, sei $\kappa$ eine Monadeninstanz und sei $p :: \kappa\ a \rightarrow a$, d.h. $p$ ist die erwähnte Funktion, die den reinen Wert aus dem monadischen Kontext extrahiert.
%Wenn folgende Aussagen gelten:
%
%\begin{itemize}
%\item $p \circ return_{\kappa} = id$
%\item Für beliebige Typen $t, t'$ und beliebige $m :: k\ t, k :: t \rightarrow k t'$ gilt\\
%$p (m\ {>>=}_{\kappa}\ k) = p\ (k\ (p\ m))$
%\end{itemize}
%
%dann liefert $p \circ f_{\kappa}$ das gleiche Eregbnis für beliebige Listen gleicher Länge, deren Elemente an jeweils gleicher Position
%die gleichen p-Bilder haben, sprich: den gleichen reinen Anteil. Man kann $p \circ f_{\kappa}$ kann also auch erhalten durch
%$g \circ (map\ p)$ für eine passende Funktion $g :: [Int] \rightarrow Int$ \cite{voigtlander}.
%
%\includegraphics[height=100px]{safe-value-extraction}
%
%Für diese Aussage werden keine Monadengesetze benötigt.