% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Einleitung}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\label{sec:einleitung}

Das Typsystem einer Programmiersprache hat einen erheblichen Einfluss darauf, wie sich die Arbeit mit dieser
Sprache gestaltet. Natürlich wird man jedes Programm, das mit einem statischen Typsystem entwickelt wurde,
auch mit dynamischen Typen schreiben können. Dennoch bietet statische Typsicherheit einen nicht zu unterschätzenden Vorteil --
nicht nur während der Entwicklung. \todo{kommt dazu noch mehr?}
%Natürlich kann man mit einer streng statisch getypten Sprache nichts entwickeln, das man nicht
%auch mit einem dynamischen Typsystem programmieren kann. Dennoch bietet statische Typisierung nicht nur beim Programmieren
%selbst unbestreitbare Vorteile.

Haskell ist eine funktionale Programmiersprache mit einem statischen Typ\-sys\-tem. Wie es bei vielen funktionalen
Programmiersprachen der Fall ist, basiert auch Haskells Typsystem auf dem Hindley/Milner System \cite{hindley, milner, damas} \todo{Referenzen besser in den Textfluss einbauen}, was es
Haskell ermöglicht, zu jedem Ausdruck automatisch eine Typsignatur herzuleiten, die den allgemeinsten Typ dieses Ausdrucks
darstellt \cite{wadler}.

Und das ist der Grundsatz: \textit{Jeder} Ausdruck hat einen ganz bestimmten Typ. Dieser Typ steht fest und wird sich auch während der Programmausführung
nicht ändern. Kann ein solcher Typ nicht hergeleitet werden, dann kompiliert das Programm gar nicht erst.
%Jeder Ausdruck in Haskell hat einen ganz bestimmten Typen, und wenn dieser Typ nicht passt, dann kompiliert auch
%das Programm nicht.

Der offensichtliche Vorteil für den Entwickler ist, dass viele unerwünschte Programmzustände gar nicht erst auftreten,
weil sie bereits durch Typfehler abgefangen werden, während eine Programmiersprache mit dynamischem Typsystem solche
Probleme ohne Fehlermeldung durchwinken würde \todo{Beispiel?}, was nicht selten schwer nachvollziehbare Laufzeitfehler zur Folge hat.

%Außerdem kann der Entwickler in Haskell
Haskell bietet dem Entwickler zudem die Möglichkeit, zu jedem Ausdruck eine eigene Typsignatur anzugeben. Das führt nicht dazu,
dass Haskell Ausdrücke auf einmal als völlig andere Typen interpretiert. Vielmehr bedeutet das, dass Haskell Typen, die der
Benutzer manuell angegeben hat, ebenfalls akzeptiert, sofern es sich dabei um Spezialisierungen des allgemeinsten Typs handelt\footnote{Manchmal können Typannotationen einen Unterschied machen, beispielsweise in Verbindung mit Typklassen.}.
Das bietet vor allem den Vorteil, dass Haskell weiß, was der Entwickler erwartet. Es ist durchaus möglich, dass Haskell trotz eines
Denkfehlers des Entwicklers einen Typ herleiten kann, der zur Funk\-tions\-de\-kla\-rati\-on passt -- mit dem man aber nicht rechnet.
\todo{Beispiel angeben} Das Typsystem ist also ein wichtiger Faktor bezüglich Fehleranfälligkeit und -prävention.
%Durch Typsignaturen hat Haskell jedoch einen Anhaltspunkt, was der Entwickler erwartet. Es ist ja durchaus
%möglich, dass Haskell trotz eines Denkfehlers des Entwicklers einen Typen herleiten kann, der auf die Funk\-tions\-de\-kla\-rati\-on passt, mit dem man aber nicht rechnet.
%Das Typsystem ist also ein wichtiger Faktor bezüglich Fehleranfälligkeit und -prävention.

%eigene Typsignaturen angeben und erhält sofort einen Typfehler, wenn die tatsächlich inferierten Typen nicht mit den
%erwarteten Typsignaturen übereinstimmen. Das Typsystem ist also ein wichtiger Faktor bezüglich Fehleranfälligkeit und
%-prävention.
Besonders vorteilhaft ist Haskells Typsystem aber, um Schlüsse aus Funk\-tions\-sig\-na\-tu\-ren zu ziehen. Betrachtet man eine solche Signatur, offenbart sich oft schon ein Teil der Funktionalität, da die
Einschränkungen des Typsystems wenig Spielraum für unerwartetes Verhalten lassen. Die folgende Zeile zeigt ein Beispiel
für eine solche Funktionstypsignatur.
%
%Die funktionale Programmiersprache Haskell bietet ein komplexes Typsystem, das auf der Typinferenz nach Hindley-Milner basiert \todo{cite}.
%Zu jedem Ausdruck lässt sich eine Typsignatur herleiten, die den allgemeinsten Typen dieses Ausdrucks darstellt. Außerdem
%kann der Programmierer zu jedem Ausdruck eine Typsignatur angeben, was zur Übersicht beiträgt und Fehlern vorbeugt.
%Das Typsystem ist so mächtig, dass die Typsignatur allein schon sehr viele Rückschlüsse über die zugehörige Funktion ermöglicht.
%Betrachten wir beispielhaft die folgende Signatur.

\begin{minted}{haskell}
test :: (a -> b) -> [a] -> [b]
\end{minted}

Es handelt sich um eine Funktion namens \texttt{test}, die als ersten Parameter eine Funktion erwartet, die von einem beliebigen
Typ in einen anderen (oder den gleichen) beliebigen Typen abbildet. Beim zweiten Parameter muss es sich um eine Liste handeln,
deren Listenelemente vom Typen $a$ sein müssen, also vom Typen, den die als ersten Parameter übergebene Funktion als
Eingabewert erwartet.

Allein durch diesen Typ lässt sich bereits erahnen, was sich ungefähr hinter dieser Funktion verbirgt.
Es ist anzunehmen, dass die  Funktion \texttt{test} die Eingabeliste mithilfe der übergebenen Funktion manipuliert und die
resultierende Liste zurückgibt. Natürlich ist es nicht gesagt, dass sie das tut, es drängt sich aber die Annahme auf, dass sie
etwas ``Ähnliches'' tun muss - einfach deshalb, weil ihr aufgrund des Typs nichts anderes übrig bleibt. \todo{explizites beispiel}
%Natürlich kann man nicht einfach davon ausgehen, dass die Funktion in ihrer Implementierung die Funktion des ersten Parameters
%auf jedes Listenelement des zweiten Parameters anwendet und das Ergebnis zurückgibt, aber eine ähnliche Funktionsweise
%ist zu erwarten - einfach aus dem Grund, dass die Funktion ``nicht viel anderes'' mit den gegebenen Typen machen kann.

Haskell stellt in der Prelude\footnote{Die Prelude ist Haskells Standardbibliothek, die automatisch importiert wird \cite{haskell}.}
eine Funktion \texttt{map} bereit, die die gleiche Signatur wie unsere Beispielfunktion \texttt{test} hat. Und \texttt{map} macht tatsächlich genau das, was
man erwarten würde: Es wendet die übergebene Funktion auf jedes Element der übergebenen Liste an und liefert die Ergebnisliste.
%Haskell liefert eine solche Funktion in der , man kennt sie unter dem Namen \texttt{map}.
Dass sich \texttt{test} und
\texttt{map} eine Typsignatur teilen, lässt Rückschlüsse auf eine ähnliche Funktionsweise zu. Dass diese Ähnlichkeit
nicht auf vage Mutmaßungen beschränkt ist, sondern dass sogar ganz systematisch konkrete Aussagen zu beliebigen Typsignaturen
hergeleitet werden können, ist Thema der sogenannten \textit{freien Theoreme}, auf die in Kapitel \ref{sec:freie-theoreme}
genauer eingegangen wird.
%das wird thematisiert in Kapitel \ref{sec:freie-theoreme}, in dem es um die sogenannten
%\textit{freien Theoreme} geht - Aussagen, die sich für beliebige Typsignaturen herleiten lassen.

Da die Herleitung dieser freien Theoreme ganz systematisch und immer gleich abläuft, kann sie auch ohne Probleme
programmatisch erledigt werden. Das Haskell-Paket \textit{free-theorems} \cite{freetheorems} enthält eine Bibliothek, die
genau diese Aufgabe erledigt, und für die sogar eine Weboberfläche existiert \cite{freetheoremswebui}.
Diese Bibliothek ermöglicht es, Haskell-Code einzulesen und aus beliebigen Typsignaturen die entsprechenden freien
Theoreme zu generieren, wobei sogar eigene Datentypen in den Signaturen verwendet werden können.
%Die Weboberfläche geht sogar noch einen Schritt weiter und kennt bereits eine Reihe wichtiger Deklarationen aus der Haskell-Prelude.
Die Web\-ober\-flä\-che enthält darüber hinaus  eine Liste bekannter Deklarationen aus der Prelude.

%Die Herleitung freier Theoreme ist so generisch, dass sie auch programmtisch erledigt werden kann. Genau das macht
%\cite{bla} \todo{cite} - hierbei handelt es sich um die Bibliothek \textit{free-theorems}, die es ermöglicht, Haskell-Code einzulesen
%und aus beliebigen Typsignaturen Formeln zu generieren, die die entsprechenden freien Theoreme repräsentieren. Zudem gibt es
%mit \cite{x} \todo{cite} eine Webanwendung, die einen Zugriff auf die Funktionen der Bibliothek ermöglicht.
%Leider bietet die Bibliothek \textit{free-theorems} nicht sämtliche Sprachfunktionen von Haskell an. 

Neben algebraischen Datentypen ist es in Haskell auch möglich, eigene Typklassen zu definieren und in
Typsignaturen zu verwenden. Ein prominentes Beispiel für eine Typklasse ist \texttt{Eq}. Dabei handelt es sich um
die Klasse der vergleichbaren Datentypen, die den Gleichheitsoperator \texttt{==} definiert.

Allein in der Prelude sind Typklassen allgegenwärtig, da sie mit Ad-Hoc-Poly\-mor\-phis\-mus ein mächtiges Werkzeug bieten,
um Programme zu strukturieren. Die Bibliothek \textit{free-theorems} unterstützt die Verwendung von Typklassen. Es ist möglich, eigene
Klassen zu deklarieren und freie Theoreme aus Typsignaturen zu generieren, in denen Typklassen verwendet werden.
%Typklassen sind ein praktisches Sprachelement von Haskell, weshalb es sinnvoll ist,
%dass sie von \textit{free-theorems} unterstützt werden.

Allerdings unterstützt die Bibliothek lediglich Typklassen für Datentypen, die keine Typparameter haben. Haskell erlaubt es,
Datentypen zu definieren, die Typen als Parameter erwarten. Haskell erlaubt es ebenso, Typklassen für parametrisierte
Datentypen zu deklarieren. Dass es sich dabei nicht um eine unwichtige Kleinigkeit im Sprachumfang von Haskell handelt, wird spätestens klar, wenn man
sich in Erinnerung ruft, dass auch die bekannte Typklasse \texttt{Monad} eine Typkonstruktorklasse ist, die in Haskell sehr häufig
Anwendung findet.

Es ist also wünschenswert, \textit{free-theorems} derart zu erweitern, dass es auch mit Typkonstruktorklassen zurecht kommt und
freie Theoreme für entsprechende Typsignaturen generieren kann. Und genau darauf liegt der Fokus dieser Arbeit. Es wird
erläutert, wie die Bibliothek und insbesondere die Anpassungen für Typkonstruktorklassen aussehen.

Dazu wird in Kapitel \ref{sec:grundlagen} zunächst auf die mathematischen Grundlagen eingegangen, also Notationen, Definitionen,
etc., die für das Verständnis der daraufhin folgenden Abschnitte benötigt werden.
Die allgemeine Herangehensweise zum Herleiten freier Theoreme ist dann das Thema von Kapitel \ref{sec:freie-theoreme}, in dem
das sogenannte \textit{Parametrizitäts-Theorem} eingeführt wird, das dann zu freien Theoremen führt.
Am Ende des Kapitels geht es dann um die Erweiterung der Theorie auf Typkonstruktorklassen. Um die Anwendbarkeit dieser
Theorie zu motivieren, werden daraufhin einige Anwendungsbeispiele gegeben.

%Dazu wird zunächst auf die
%Grundlagen eingegangen, die benötigt werden, um die Theorie dahinter zu verstehen. Im folgenden Abschnitt geht es um das
%allgemeine Vorgehen beim Herleiten freier Theoreme. Insbesondere wird dabei auch auf Typkonstruktorklassen eingegangen.

%Ein wichtiger Aspekt
%bei der Programmierung in Haskell sind Typklassen. Sie ermöglichen es, Datenstrukturen in Klassen einzuordnen, und für diese
%Klassen Funktionen anzugeben, die pro Datentyp implementiert werden können. Kurz gesagt erlauben Typklassen Ad-Hoc-Polymorphismus in Haskell.

%Zwar unterstützt die Bibliothek Typklassen, allerdings nur für Datentypen, die keinen Typen als Parameter erwarten. Die
%bekanntere \texttt{Monad}-Klasse beispielsweise ist für Datentypen definiert, die einen Typparameter haben. Eine Verwendung
%mit der \texttt{free-theorems} Bibliothek ist somit nicht möglich, oftmals möchte man aber nicht auf solche Typklassen verzichten.
%Grundsätzlich unterscheidet sich die Verwendung von Typkonstruktorklassen gar nicht gravierend von einfachen Typklassen.

%Ich habe die Bibliothek um eine entsprechende Funktionalität erweitert. In der vorliegenden Arbeit wird erläutert, wie die Bibliothek
%und insbesondere die Anpassungen für Typkonstruktorklassen aussehen. Dazu wird zunächst auf die Grundlagen eingegangen,
%die benötigt werden, um die Theorie dahinter zu verstehen. Im folgenden Abschnitt geht es um das allgemeine Vorgehen beim
%Herleiten freier Theoreme. Insbesondere wird dabei auch auf Typkonstruktorklassen eingegangen.

Schließlich wird in Kapitel \ref{sec:free-theorems} die Bibliothek \textit{free-theorems} etwas genauer beschrieben, wobei
insbesondere auf den Aufbau und die grundsätzliche Aufteilung eingegangen wird. Die nötigen Anpassungen für die Erweiterung um
Typkonstruktorklassen sind dann in Kapitel \ref{sec:erweiterung-um-typklassen} zu finden.
%um dann im darauf folgenden Abschnitt zu erläutern, an welchen Stellen diese
%Bibliothek erweitert werden muss, um die zusätzliche Funktionalität für Typkonstruktorklassen zu leisten.

In dieser Arbeit wird dabei größtenteils von einer vereinfachten Teilsprache von Haskell ausgegangen, die weder Striktheit noch den Fixpunktoperator kennt. Das reicht nicht aus, um alle realen Haskell-Programme zu beschreiben, und in Kapitel \ref{sec:striktheit-und-rekursion}
wird genauer darauf eingegangen, welche Konzepte in dieser Teilsprache fehlen und wie sie von \textit{free-theorems} behandelt
werden.
%In dieser Arbeit wird dabei größtenteils von einer vereinfachten Teilsprache von Haskell ausgegangen, die weder Striktheit noch
%den Fixpunktoperator kennt. Natürlich entspricht dies nicht immer den realen Begebenheiten, und die Bibliothek
%\texttt{free-theorems} berücksichtigt dies bereits, indem sie unterschiedliche Teilsprachen anbietet, die die entsprechenden
%Sprachfunktionen berücksichtigen. Die Erweiterungen für Typkonstruktorklassen berücksichtigen diese Problematik derzeit noch
%nicht. Kapitel \ref{sec:striktheit-und-rekursion} geht genauer darauf ein, inwiefern \texttt{seq} und \texttt{fix} in Verbindung
%mit freien Theoremen problematisch sind.

Am Ende der Arbeit findet sich schließlich ein zusammenfassendes Kapitel und ein Ausblick, der Anstöße für zukünftige Arbeiten
liefert.

%Die eingeführten Erweiterungen für Typkonstruktorklassen gehen von einer Basissprache ohne diese Besonderheiten aus.
%In Abschnitt \ref{sec:striktheit-und-rekursion} wird kurz erläutert, welche Auswirkungen diese Besonderheiten haben, in der
%Implementierung sind sie noch nicht vorgesehen - hier ist noch Raum für Erweiterungen. \todo{würde man das hier schreiben?}