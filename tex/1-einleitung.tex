% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Einleitung}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\label{sec:einleitung}

Das Typsystem einer Programmiersprache hat einen erheblichen Einfluss darauf, wie sich die Arbeit mit dieser
Sprache gestaltet. Natürlich wird man jedes Programm, das mit einem statischen Typsystem entwickelt wurde,
auch mit dynamischen Typen schreiben können. Dennoch bietet statische Typsicherheit deutliche Vorteile --
nicht nur während der Entwicklung. Ein Vorteil ist die Möglichkeit, wertvolle Erkenntnisse allein aus den verwendeten
Typen des Programms zu ziehen. Und genau das ist ein zentrales Thema dieser Arbeit.
%Natürlich kann man mit einer streng statisch getypten Sprache nichts entwickeln, das man nicht
%auch mit einem dynamischen Typsystem programmieren kann. Dennoch bietet statische Typisierung nicht nur beim Programmieren
%selbst unbestreitbare Vorteile.

Haskell ist eine funktionale Programmiersprache mit einem statischen Typ\-sys\-tem. Wie es bei vielen funktionalen
Programmiersprachen der Fall ist, basiert auch Haskells Typsystem auf dem Hindley/Milner System \cite{hindley, milner}, was es
Haskell ermöglicht, zu jedem Ausdruck automatisch eine Typsignatur herzuleiten, die den allgemeinsten Typ dieses Ausdrucks
darstellt \cite{wadler}.

Und das ist der Grundsatz: \textit{Jeder} Ausdruck hat einen ganz bestimmten Typ. Dieser Typ steht fest und wird sich auch während der Programmausführung
nicht ändern. Kann ein solcher Typ nicht hergeleitet werden, dann kompiliert das Programm gar nicht erst.
%Jeder Ausdruck in Haskell hat einen ganz bestimmten Typen, und wenn dieser Typ nicht passt, dann kompiliert auch
%das Programm nicht.

Der offensichtliche Vorteil für den Entwickler ist, dass viele unerwünschte Programmzustände gar nicht erst auftreten,
weil sie bereits durch Typfehler abgefangen werden, während eine Programmiersprache mit dynamischem Typsystem solche
Probleme ohne Fehlermeldung durchwinken würde, was nicht selten schwer nachvollziehbare Laufzeitfehler zur Folge hat.
Betrachten wir zum Beispiel die folgende Funktion der Skriptsprache \textit{Javascript} \cite{javascript}.

\begin{minted}{javascript}
function sum(a, b)
{
   return a + b;
}
\end{minted}

Javascript hat ein dynamisches Typsystem, das heißt es können beim Aufruf der Funktion \texttt{sum} Parameter beliebiger Typen
übergeben werden. Ein Laufzeitfehler tritt dann auf, wenn zwei Werte \texttt{a} und \texttt{b} übergeben werden, auf die
der Operator \texttt{+} nicht angewandt werden kann (ein Beispiel hierfür wären Funktionen). Problematisch ist auch der Fall, in
dem zwei Parameter übergeben werden, auf die der \texttt{+}-Operator zwar angewandt werden kann, jedoch nicht das erwartete
Ergebnis liefert. Ein Aufruf von \texttt{sum("42", 7)} würde beispielsweise zum Ergebnis \texttt{"427"} führen.

%Außerdem kann der Entwickler in Haskell
Trotz automatisch hergeleiteten Typen bietet Haskell dem Entwickler zusätzlich die Möglichkeit, zu jedem Ausdruck eine eigene
Typsignatur anzugeben. Das führt nicht dazu,
dass Haskell Ausdrücke auf einmal als völlig andere Typen interpretiert. Vielmehr bedeutet das, dass Haskell Typen, die der
Benutzer manuell angegeben hat, ebenfalls akzeptiert, sofern es sich dabei um Spezialisierungen des allgemeinsten Typs handelt\footnote{Manchmal können Typannotationen einen Unterschied machen, beispielsweise in Verbindung mit Typklassen.}.

Das bietet vor allem den Vorteil, dass Haskell weiß, was der Entwickler erwartet. Es ist durchaus möglich, dass Haskell trotz eines
Denkfehlers des Entwicklers einen Typ herleiten kann, der zur Funk\-tions\-de\-kla\-rati\-on passt -- mit dem man aber nicht rechnet.
Das folgende Beispiel soll veranschaulichen, wie ein solcher Fehler zustande kommen kann.

\begin{minted}{haskell}
concatStrings a b = a : b
\end{minted}

Die angegebene Funktion soll zwei Zeichenketten konkatenieren, verwendet aber statt des Konkatenationsoperators \texttt{++} fälschlicherweise den
Listenkonstruktor \texttt{:}. Das hat zur Folge, dass Haskell als ersten Parameter $a$ ein Listenelement statt einer Liste erwartet,
es ergeben sich jedoch keine Probleme mit der Typsignatur. Problematisch wird es erst, wenn versucht wird, die Funktion
aufzurufen, beispielsweise mit dem folgenden Aufruf, wobei \texttt{b} eine Zeichenkette ist.

\begin{minted}{haskell}
concatStrings "Student#" b
\end{minted}

Haskell erkennt, dass der
Funktionsaufruf nicht mit der (automatisch ermittelten) Funktionssignatur kompatibel ist und erzeugt einen Kompilierfehler. Die
Fehlermeldung besagt allerdings, dass der Typ \texttt{[Char]} nicht mit dem erwarteten Typ \texttt{Char} übereinstimmt
und gibt als Fehlerposition den Funktionsaufruf an.

Hätte der Entwickler die erwartete Typsignatur \texttt{[Char] -> [Char] -> [Char]} angegeben, dann hätte bereits die Typsignatur
einen Fehler erzeugt, da sie kein Spezialfall der automatisch hergeleiteten Signatur \texttt{a -> [a] -> [a]} ist. Zusammenfassend kann man sagen, dass das Typsystem ein wichtiger Faktor bezüglich Fehleranfälligkeit und -prävention ist.
%Durch Typsignaturen hat Haskell jedoch einen Anhaltspunkt, was der Entwickler erwartet. Es ist ja durchaus
%möglich, dass Haskell trotz eines Denkfehlers des Entwicklers einen Typen herleiten kann, der auf die Funk\-tions\-de\-kla\-rati\-on passt, mit dem man aber nicht rechnet.
%Das Typsystem ist also ein wichtiger Faktor bezüglich Fehleranfälligkeit und -prävention.

%eigene Typsignaturen angeben und erhält sofort einen Typfehler, wenn die tatsächlich inferierten Typen nicht mit den
%erwarteten Typsignaturen übereinstimmen. Das Typsystem ist also ein wichtiger Faktor bezüglich Fehleranfälligkeit und
%-prävention.
Besonders vorteilhaft ist Haskells Typsystem aber, um Schlüsse aus Funk\-tions\-sig\-na\-tu\-ren zu ziehen. Betrachtet man eine solche Signatur, offenbart sich oft schon ein Teil der Funktionalität, da die
Einschränkungen des Typsystems wenig Spielraum für unerwartetes Verhalten lassen. Die folgende Zeile zeigt ein Beispiel
für eine solche Funktionstypsignatur.
%
%Die funktionale Programmiersprache Haskell bietet ein komplexes Typsystem, das auf der Typinferenz nach Hindley-Milner basiert \todo{cite}.
%Zu jedem Ausdruck lässt sich eine Typsignatur herleiten, die den allgemeinsten Typen dieses Ausdrucks darstellt. Außerdem
%kann der Programmierer zu jedem Ausdruck eine Typsignatur angeben, was zur Übersicht beiträgt und Fehlern vorbeugt.
%Das Typsystem ist so mächtig, dass die Typsignatur allein schon sehr viele Rückschlüsse über die zugehörige Funktion ermöglicht.
%Betrachten wir beispielhaft die folgende Signatur.

\begin{minted}{haskell}
applyOnList :: (a -> b) -> [a] -> [b]
\end{minted}

Es handelt sich um eine Funktion namens \texttt{applyOnList}, die als ersten Parameter eine Funktion erwartet, die einen beliebigen
Typ auf einen anderen (oder den gleichen) beliebigen Typ abbildet. Beim zweiten Parameter muss es sich um eine Liste handeln,
deren Listenelemente vom Typ $a$ sind, also vom Typ, den die als erster Parameter übergebene Funktion als
Eingabewert erwartet.

Allein durch diesen Typ lässt sich bereits erahnen, was sich ungefähr hinter dieser Funktion verbirgt.
Es ist anzunehmen, dass die  Funktion \texttt{applyOnList} die Eingabeliste mithilfe der übergebenen Funktion manipuliert und die
resultierende Liste zurückgibt. Natürlich ist es nicht gesagt, dass sie das tut, es drängt sich aber die Annahme auf, dass sie
etwas ``Ähnliches'' tun muss -- einfach deshalb, weil es der Typ suggeriert.
%Natürlich kann man nicht einfach davon ausgehen, dass die Funktion in ihrer Implementierung die Funktion des ersten Parameters
%auf jedes Listenelement des zweiten Parameters anwendet und das Ergebnis zurückgibt, aber eine ähnliche Funktionsweise
%ist zu erwarten - einfach aus dem Grund, dass die Funktion ``nicht viel anderes'' mit den gegebenen Typen machen kann.

Haskell stellt in der Prelude\footnote{Die Prelude ist Haskells Standardbibliothek, die automatisch importiert wird \cite{haskell}.}
eine Funktion \texttt{map} bereit, die die gleiche Signatur wie unsere Beispielfunktion \texttt{test} hat. Und \texttt{map} macht tatsächlich genau das, was
man erwarten würde: Es wendet die übergebene Funktion auf jedes Element der übergebenen Liste an und liefert die Ergebnisliste.
%Haskell liefert eine solche Funktion in der , man kennt sie unter dem Namen \texttt{map}.
Dass sich \texttt{test} und
\texttt{map} eine Typsignatur teilen, lässt Rückschlüsse auf eine ähnliche Funktionsweise zu. Dass diese Ähnlichkeit
nicht auf vage Mutmaßungen beschränkt ist, sondern dass sogar ganz systematisch konkrete Aussagen zu beliebigen Typsignaturen
hergeleitet werden können, ist Thema der sogenannten \textit{freien Theoreme}, auf die in Kapitel \ref{sec:freie-theoreme}
genauer eingegangen wird.
%das wird thematisiert in Kapitel \ref{sec:freie-theoreme}, in dem es um die sogenannten
%\textit{freien Theoreme} geht - Aussagen, die sich für beliebige Typsignaturen herleiten lassen.

Da die Herleitung dieser freien Theoreme ganz systematisch und immer gleich abläuft, kann sie auch ohne Probleme
programmatisch erledigt werden. Das Haskell-Paket \textit{free-theorems} \cite{freetheorems} enthält eine Bibliothek, die
genau diese Aufgabe erledigt, und für die sogar eine Weboberfläche existiert \cite{freetheoremswebui}.
Diese Bibliothek ermöglicht es, Haskell-Code einzulesen und aus beliebigen Typsignaturen die entsprechenden freien
Theoreme zu generieren, wobei sogar eigene Datentypen in den Signaturen verwendet werden können.
%Die Weboberfläche geht sogar noch einen Schritt weiter und kennt bereits eine Reihe wichtiger Deklarationen aus der Haskell-Prelude.
Die Web\-ober\-flä\-che enthält darüber hinaus  eine Liste bekannter Deklarationen aus der Prelude.

%Die Herleitung freier Theoreme ist so generisch, dass sie auch programmtisch erledigt werden kann. Genau das macht
%\cite{bla} \todo{cite} - hierbei handelt es sich um die Bibliothek \textit{free-theorems}, die es ermöglicht, Haskell-Code einzulesen
%und aus beliebigen Typsignaturen Formeln zu generieren, die die entsprechenden freien Theoreme repräsentieren. Zudem gibt es
%mit \cite{x} \todo{cite} eine Webanwendung, die einen Zugriff auf die Funktionen der Bibliothek ermöglicht.
%Leider bietet die Bibliothek \textit{free-theorems} nicht sämtliche Sprachfunktionen von Haskell an. 

Neben algebraischen Datentypen ist es in Haskell auch möglich, eigene Typklassen zu definieren und in
Typsignaturen zu verwenden. Ein prominentes Beispiel für eine Typklasse ist \texttt{Eq}. Dabei handelt es sich um
die Klasse der vergleichbaren Datentypen, die den Gleichheitsoperator \texttt{==} definiert.

Allein in der Prelude sind Typklassen allgegenwärtig, da sie mit Ad-Hoc-Poly\-mor\-phis\-mus ein mächtiges Werkzeug bieten,
um Programme zu strukturieren. Die Bibliothek \textit{free-theorems} unterstützt die Verwendung von Typklassen. Es ist möglich, eigene
Klassen zu deklarieren und freie Theoreme aus Typsignaturen zu generieren, in denen Typklassen verwendet werden.
%Typklassen sind ein praktisches Sprachelement von Haskell, weshalb es sinnvoll ist,
%dass sie von \textit{free-theorems} unterstützt werden.

Allerdings unterstützt die Bibliothek lediglich Typklassen für Datentypen, die keine Typparameter haben. Haskell erlaubt es,
Datentypen zu definieren, die Typen als Parameter erwarten. Haskell erlaubt es ebenso, Typklassen für parametrisierte
Datentypen zu deklarieren. Dass es sich dabei nicht um eine unwichtige Kleinigkeit im Sprachumfang von Haskell handelt, wird spätestens klar, wenn man
sich in Erinnerung ruft, dass auch die bekannte Typklasse \texttt{Monad} eine Typkonstruktorklasse ist, die in Haskell sehr häufig
Anwendung findet.

Es ist also wünschenswert, \textit{free-theorems} derart zu erweitern, dass es auch mit Typkonstruktorklassen zurecht kommt und
freie Theoreme für entsprechende Typsignaturen generieren kann. Und genau darauf liegt der Fokus dieser Arbeit. Es wird
erläutert, wie die Bibliothek und insbesondere die Anpassungen für Typkonstruktorklassen aussehen.

Dazu wird in Kapitel \ref{sec:grundlagen} zunächst auf die mathematischen Grundlagen eingegangen, also Notationen, Definitionen,
etc., die für das Verständnis der daraufhin folgenden Abschnitte benötigt werden.
Die allgemeine Herangehensweise zum Herleiten freier Theoreme ist dann das Thema von Kapitel \ref{sec:freie-theoreme}, in dem
das sogenannte \textit{Parametrizitätstheorem} eingeführt wird, das dann zu freien Theoremen führt.
Am Ende des Kapitels geht es dann um die Erweiterung der Theorie auf Typkonstruktorklassen. Um die Anwendbarkeit dieser
Theorie zu motivieren, werden daraufhin einige Anwendungsbeispiele gegeben.

%Dazu wird zunächst auf die
%Grundlagen eingegangen, die benötigt werden, um die Theorie dahinter zu verstehen. Im folgenden Abschnitt geht es um das
%allgemeine Vorgehen beim Herleiten freier Theoreme. Insbesondere wird dabei auch auf Typkonstruktorklassen eingegangen.

%Ein wichtiger Aspekt
%bei der Programmierung in Haskell sind Typklassen. Sie ermöglichen es, Datenstrukturen in Klassen einzuordnen, und für diese
%Klassen Funktionen anzugeben, die pro Datentyp implementiert werden können. Kurz gesagt erlauben Typklassen Ad-Hoc-Polymorphismus in Haskell.

%Zwar unterstützt die Bibliothek Typklassen, allerdings nur für Datentypen, die keinen Typen als Parameter erwarten. Die
%bekanntere \texttt{Monad}-Klasse beispielsweise ist für Datentypen definiert, die einen Typparameter haben. Eine Verwendung
%mit der \texttt{free-theorems} Bibliothek ist somit nicht möglich, oftmals möchte man aber nicht auf solche Typklassen verzichten.
%Grundsätzlich unterscheidet sich die Verwendung von Typkonstruktorklassen gar nicht gravierend von einfachen Typklassen.

%Ich habe die Bibliothek um eine entsprechende Funktionalität erweitert. In der vorliegenden Arbeit wird erläutert, wie die Bibliothek
%und insbesondere die Anpassungen für Typkonstruktorklassen aussehen. Dazu wird zunächst auf die Grundlagen eingegangen,
%die benötigt werden, um die Theorie dahinter zu verstehen. Im folgenden Abschnitt geht es um das allgemeine Vorgehen beim
%Herleiten freier Theoreme. Insbesondere wird dabei auch auf Typkonstruktorklassen eingegangen.

Schließlich wird in Kapitel \ref{sec:free-theorems} die Bibliothek \textit{free-theorems} etwas genauer beschrieben, wobei
insbesondere auf den Aufbau und die grundsätzliche Aufteilung eingegangen wird. Die nötigen Anpassungen für die Erweiterung um
Typkonstruktorklassen sind dann in Kapitel \ref{sec:erweiterung-um-typklassen} zu finden.
%um dann im darauf folgenden Abschnitt zu erläutern, an welchen Stellen diese
%Bibliothek erweitert werden muss, um die zusätzliche Funktionalität für Typkonstruktorklassen zu leisten.

In dieser Arbeit wird dabei größtenteils von einer vereinfachten Teilsprache von Haskell ausgegangen, die weder Striktheit noch den Fixpunktoperator kennt. Das reicht nicht aus, um alle realen Haskell-Programme zu beschreiben, und in Kapitel \ref{sec:striktheit-und-rekursion}
wird genauer darauf eingegangen, welche Konzepte in dieser Teilsprache fehlen und wie sie von \textit{free-theorems} behandelt
werden.
%In dieser Arbeit wird dabei größtenteils von einer vereinfachten Teilsprache von Haskell ausgegangen, die weder Striktheit noch
%den Fixpunktoperator kennt. Natürlich entspricht dies nicht immer den realen Begebenheiten, und die Bibliothek
%\texttt{free-theorems} berücksichtigt dies bereits, indem sie unterschiedliche Teilsprachen anbietet, die die entsprechenden
%Sprachfunktionen berücksichtigen. Die Erweiterungen für Typkonstruktorklassen berücksichtigen diese Problematik derzeit noch
%nicht. Kapitel \ref{sec:striktheit-und-rekursion} geht genauer darauf ein, inwiefern \texttt{seq} und \texttt{fix} in Verbindung
%mit freien Theoremen problematisch sind.

Am Ende der Arbeit findet sich schließlich ein zusammenfassendes Kapitel und ein Ausblick, der Anstöße für zukünftige Arbeiten
liefert.

%Die eingeführten Erweiterungen für Typkonstruktorklassen gehen von einer Basissprache ohne diese Besonderheiten aus.
%In Abschnitt \ref{sec:striktheit-und-rekursion} wird kurz erläutert, welche Auswirkungen diese Besonderheiten haben, in der
%Implementierung sind sie noch nicht vorgesehen - hier ist noch Raum für Erweiterungen. \todo{würde man das hier schreiben?}