% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Erweiterung um Typkonstruktorklassen}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\label{sec:erweiterung-um-typklassen}

In den bisherigen Abschnitten wurden die Grundlagen zu freien Theoremen erklärt, es wurde erläutert, wie freie Theoreme
aussehen, wenn Typkonstruktorklassen eine Rolle spielen, und es wurde ein Einblick in die Bibliothek \textit{free-theorems}
gegeben. Es sind jetzt alle Werkzeuge vorhanden, um die Bibliothek so zu erweitern, dass auch Typkonstruktorklassen möglich
sind, deren Typparameter die Sorte $* \rightarrow *$ haben. Und natürlich muss es möglich sein, Typsignaturen zu schreiben,
in denen Typvariablen auf solche Klassen beschränkt und auf Typparameter angewandt werden.

Dieses Kapitel ist ähnlich gegliedert wie Kapitel \ref{sec:free-theorems}: Die einzelnen Abschnitte entsprechen den Funktionen,
die bei der Verwendung der Bibliothek durchlaufen werden. Dabei wird jeweils erläutert, inwiefern sich Funktionsweisen ändern
bzw. neue Funktionalitäten hinzugefügt werden. Insbesondere wird ein Blick auf die internen Datenstrukturen gegeben,
die hier eine Rolle spielen.
%Dieses Kapitel ist aufgeteilt in die verschiedenen Schritte, die bei der Verwendung der Bibliothek durchlaufen werden. Es
%wird jeweils darauf eingegangen, welche Änderungen notwendig sind und was jeweils zu beachten ist, um Typkonstruktorklassen
%zu unterstützen.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterungen der BasicSyntax}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Alles beginnt bei der Syntax. Der Zweck der vereinfachten \texttt{BasicSyntax} war, dass nicht verwendete Sprachkonstrukte
ignoriert werden können. Typvariablen, die auf andere Typen angewandt werden, gehörten bisher zu diesen vernachlässigbaren
Konstrukten. Da im Hintergrund aber ein kompletter Haskell-Parser arbeitet, lässt sich diese Erweiterung relativ einfach
wieder einpflegen.

Rein syntaktisch kann man Typkonstruktorvariablen sehen als Typvariablen, die wie Typkonstruktoren verwendet werden. Das
soll im folgenden Beispiel verdeutlicht werden.

%Bevor man mit Typkonstruktorvariablen arbeiten kann, müssen diese natürlich zunächst in der \texttt{BasicSyntax} vorgesehen
%sein. An sich verhalten sich diese ja wie andere Typvariablen auch, mit dem Unterschied, dass sie - ähnlich wie Funktionen -
%auf andere Typausdrücke angewandt werden können. Das folgende Beispiel soll dies verdeutlichen.

\begin{minted}{haskell}
test :: Monad m => m a -> (a -> m b) -> m b
\end{minted}

Das Beispiel zeigt die Signatur der Funktion \texttt{test}, in der die freie Typvariable \texttt{f} auf die Klasse \texttt{Monad}
eingeschränkt wird. Diese Klasse ist so definiert, dass sie einen Typparameter erwartet, der von der Sorte $* \rightarrow *$ ist,
folglich also selbst einen Parameter erwartet. Dementsprechend kommt in der Signatur beispielsweise der Ausdruck \texttt{f a} vor,
d.h. die Typkonstruktorvariable \texttt{f} wird angewandt auf die Typvariable \texttt{a}.

Es ist noch zu beachten, dass eine solche Applikation bei bestimmten Standardtypkonstruktoren bereits vorgesehen ist, diese
haben mit Typvariablenapplikation aber nichts zu tun. So sind \texttt{[a]} und \texttt{Maybe a} bereits möglich. Da es sich
bei \texttt{[]} und \texttt{Maybe} jedoch nicht um Variablen handelt, sondern um bekannte Typkonstruktoren, wird hier auch ein
anderer Datentyp verwendet.

Um also dieser neuen syntaktischen Möglichkeit Rechnung zu tragen, wird die \texttt{BasicSyntax} um den Konstruktor
\texttt{TypeVarApp} erweitert. Am besten wird das deutlich, wenn man betrachtet, in welchen Ausdruck das obige Beispiel
in \texttt{BasicSyntax} überführt wird - siehe hierzu Listing \ref{lst:typevarapp}.

\begin{listing}[ht]
\inputminted[tabsize=2]{haskell}{typevarapp.hs}
\caption{Beispielsignatur von test in BasicSyntax-Struktur}
\label{lst:typevarapp}
\end{listing}

Damit ist bereits die einzige benötigte Syntaxänderung eingeführt, da Klassendeklarationen bereits möglich sind. Innerhalb der
Klassendeklaration muss Variablenapplikation natürlich auch möglich sein. Das ist aber automatisch möglich, da sich die Änderungen
auf sämtliche Funktionssignaturen erstrecken, unabhängig ob Toplevel-Signaturen oder Signaturen von Klassenfunktionen.

%Da Typvariablenapplikation in \cite{freetheorems} nicht vorgesehen ist, musste ein solches Konstrukt in die BasicSyntax-Struktur eingefügt werden. Hierbei ist zu beachten: Die Applikation
%von Standardtypkonstruktoren, beispielsweise \texttt{[a]} für Listen, ist sehr wohl vorgesehen und wird in der BasicSyntax durch \texttt{TypeCon} im Datentyp \texttt{TypeExpression} dargestellt. \todo{Wahrscheinlich viel zu speziell} Diese Standardtypkonstruktoren werden in diesem Zusammenhang aber als Sonderfälle betrachtet \ref{sec:freie-theoreme}, um das System wirklich um eigene Typklassen zu erweitern, muss es auch möglich sein, Typkonstruktorvariablen auf Typen anzuwenden.
%
%Die Erweiterung der BasicSyntax sieht hier so aus, dass ein neuer Konstruktor \texttt{TypeVarApp} zum Datentypen \texttt{TypeExpression} hinzugefügt wird. In Listing \ref{lst:typevarapp} ist ein Beispiel zu sehen.
%
%\inputminted[tabsize=2]{haskell}{typevarapp.hs}
%
%Abgesehen vom offensichtlichen Problem, dass dieser Konstruktor bei der Theoremgenerierung zu Fehlern beim Pattern Matching oder zumindest zu unerwünschtem Verhalten führt,
%ist auch zu beachten, dass die in Abschnitt \ref{sec:check} erwähnte \texttt{check}-Funktion entsprechend angepasst wird.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterung von Relation}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

% Da eine neue Relationskonstruktion eingeführt wird, muss auch der entsprechende Datentyp angepasst werden.
Der abstrakte Syntaxbaum in der \texttt{BasicSyntax}-Struktur wird von der \textit{interpret}-Funktion in eine relationale
Darstellung überführt. Das folgende Beispiel beinhaltet zur Verdeutlichung ein explizites \texttt{forall}.

\begin{minted}{haskell}
test :: forall a. a -> a
\end{minted}

Die Typsignatur dieses Beispiels lässt sich als Relation $\forall \mathcal{R}. \mathcal{R} \rightarrow \mathcal{R}$ auffassen.
Dabei ist $\forall \mathcal{R}. \mathcal{A}(\mathcal{R})$ so definiert, dass über alle Relationen aller Typmengen allquantifiziert
wird (vgl. Abschnitt \ref{sec:free-theorems-param}). \todo{richtig so?} So weit ist das Vorgehen bereits bekannt und auch schon
in \textit{free-theorems} implementiert.

Interessant ist nun, wie es sich verhält, wenn eine solche Typvariable auf Typausdrücke angewandt wird, wie das folgende
Beispiel zeigt.

\begin{minted}{haskell}
test :: forall f a. Functor f => f a -> f a
\end{minted}

Dieses Beispiel wird überführt in $\forall^{\{Functor\}} \mathcal{F} \forall \mathcal{R}. \mathcal{F} \mathcal{R} \rightarrow
\mathcal{F} \mathcal{R}$, wobei $\mathcal{F}$ \textit{keine} Relation ist. Es handelt sich hierbei, im Gegensatz zu $\mathcal{R}$ aus
dem ersten Beispiel, um eine Fuktion, die eine Relation auf eine andere Relation abbildet. Es wird hier also auch nicht über
Relationen allquantifiziert, sondern über entsprechende Funktionen, was bedeutet, dass es sich um eine andere Konstruktion
handelt als die Allquantifizierung über einfache Typvariablen.

Dieser Argumentation folgend wird ein zusätzlicher Konstruktor eingeführt für die Typkonstruktorabstraktion, der
\texttt{RelTypeConsAbs} genannt wird. Außerdem wird der Konstruktor \texttt{RelTypeConsApp} eingeführt, der benutzt
wird, wenn man eine Relationsfunktion auf eine Relation anwendet, im obigen Beispiel also $\mathcal{F} \mathcal{R}$.

Tabellen \ref{tab:reltypeconsabs} und \ref{tab:reltypeconsapp} zeigen die Parameter für diese neuen Datentypkonstruktoren.

\begin{table}[th]
\begin{tabular}{ | l | l | }
\hline
RelTypeConsAbs & \\
\hline
\texttt{RelationInfo} & Zusätzliche Informationen zur Relation, in jedem Konstruktor \\
& enthalten. \\
\texttt{RelationVariable} & Funktionsvariable, die allquantifiziert wird. \\
\texttt{(TypeExpression,} & Funktionsvariablen auf der linken und rechten Seite. \\
\texttt{TypeExpression)} & \\
\texttt{[Restriction]} & Einschränkungen auf Klassen, aber auch auf \textit{Striktheit},\\
& \textit{Stetigkeit}, etc. \\
\texttt{Relation} & Die Relation, die die quantifizierte Variable enthält. \\
\hline
\end{tabular}
\caption{Parameter des Konstrktors \texttt{RealConsAbs}}
\label{tab:reltypeconsabs}
\end{table}

\begin{table}[th]
\begin{tabular}{ | l | l | }
\hline
RelTypeConsApp & \\
\hline
\texttt{RelationInfo} & Zusätzliche Informationen zur Relation, in jedem Konstruktor \\
& enthalten. \\
\texttt{RelationVariable} & Relationsfunktionsvariable, die auf eine Relation angewandt\\
& wird. \\
\texttt{Relation} & Relation, auf die die Typkonstruktorfunktion angewandt wird. \\
\hline
\end{tabular}
\caption{Parameterliste des Konstruktors \texttt{RealConsApp}}
\label{tab:reltypeconsapp}
\end{table}

Mit diesen Erweiterungen ist es möglich, die hinzukommenden relationalen Strukturen auszudrücken.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterung von check}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

%Da in der ursprünglichen Version von free-theorems Typkonstruktorvariablen nicht gestattet waren, konnten einige
%Fehlerüberprüfungen eingespart werden. Erlaubt man Typkonstruktorvariablen, muss man zusätzliche Fehlerfälle abdecken,
%die auftreten können. Betrachten wir das folgende Beispiel:

In der ursprünglichen Version von \textit{free-theorems} können Typkonstruktorvariablen nicht verwendet werden. Es wird eine
Fehlermeldung ausgegeben, sobald eine Typvariable auf eine andere angewandt wird. Gestattet man dies, müssen neu
entstehende Problemfälle abgedeckt werden.

Das folgende Beispiel zeigt ein solches Problem.

\begin{minted}{haskell}
test :: Functor f => f a -> f
\end{minted}

Hierbei handelt es sich nicht um eine korrekte Haskell-Typsignatur: Die Variable f wird als Functor eingeführt und in der Signatur
einmal mit einem Parameter, einmal ohne Parameter aufgerufen. Selbst wenn man die Deklaration von Functor außer Acht lässt,
kann man deutlich sehen, dass eine der beiden Vorkommen von \texttt{f} fehlerhaft ist. \texttt{f} erwartet entweder einen
oder gar keinen Parameter, unterschiedliche Parameterzahlen sind nicht gestattet.

Da Functor bekannt ist, kann man einfach die Deklaration dieser Klasse betrachten:

\begin{minted}{haskell}
class Functor f where
   fmap :: (a -> b) -> f a -> f b
\end{minted}

Anhand der Deklaration der Klassenfunktionen kann man nun sehen, dass die Variable \texttt{f} stets auf einen einzelnen 
Parameter angewandt wird, das heißt, man kann bei allen Vorkommen der Klasse Functor davon ausgehen, dass diese
auf genau einen Parameter appliziert werden müssen. Natürlich kommt hier eine weitere Überprüfung ins Spiel: Es muss
sichergestellt werden, dass die Klassenvariable - in diesem Fall f - in sämtlichen Klassenfunktionen mit der gleichen Anzahl an
Parametern verwendet werden.

Die Überprüfung innerhalb einer Klasse auf gleiche Arität aller Vorkommen der Klassenvariable ist eine lokale Überprüfung -
es wird stets nur die Klassendeklaration benötigt, ein globaler Kontext muss nicht bekannt sein. Möchte man überprüfen,
ob Typkonstruktorvariablen in beliebigen Deklarationen die korrekte Anzahl an Parametern haben, dann muss man den
globalen Kontext betrachten: Die Deklaration der Klasse muss in Betracht gezogen werden.

Eine Besonderheit ist hierbei auch, dass eine Typvariable auf mehrere Klassen gleichzeitig eingeschränkt werden kann. So ist
das folgende Beispiel legitimer Haksell-Code:

\begin{minted}{haskell}
test :: (SomeClass1 f, SomeClass2 f) => f a -> f b
\end{minted}

%Man muss also zusätzlich sicherstellen, dass alle Klassen, die für die gleichen Variablen angegeben sind, die gleiche Anzahl an
%Parametern erwarten.

Es muss also sichergestellt werden, dass alle Klassen, die pro Variable angegeben sind, die gleiche Anzahl an Parametern erwarten.
Dieses Problem erledigt sich allerdings automatisch, wenn man die rechte Seite auf Fehler überprüft, da im Falle unterschiedlicher
Aritäten mindestens einer der beiden Ausdrücke \texttt{f a} und \texttt{f b} einen Fehler erzeugen würde.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterung von interpret}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

%TODO: erklären, dass ein zusätzlicher Relationskonstruktor erzeugt wurde.

Die \texttt{interpret}-Funktion ist dafür zuständig, den abstrakten Syntaxbaum von Typsignaturen in die enstprechende
\texttt{Intermediate}-Struktur zu überführen. Natürlich sind hier Änderungen notwendig, wenn \texttt{interpret} auch
Typkonsturktorvariablen und deren Applikation erkennen und korrekt behandeln soll.

Es wurde ja bereits in Abschnitt \ref{sec:free-theorems-interpret} erläutert, wie die Funktion mit dem \textit{forall}-Konstrukt
umgeht: Es wird in eine Allquantifizierung über Relationen umgewandelt, also in einen \texttt{RelAbs}-Ausdruck.
Da es sich hierbei nicht mehr zwingend um Relationen handelt, wenn Typkonstruktorvariablen vorkommen können, sondern auch
Funktionen auf Relationen afutreten können, wird jetzt an dieser Stelle eine Fallunterscheidung eingebaut.

Im entsprechenden Abschnitt wurde auch beschrieben, dass die Implementierung von \textit{free-theorems} hier eine
\texttt{Map} als Umgebung nutzt, in der Typvariablen den dazugehörigen 

Es wird überprüft, ob die entsprechende Typvariable, über die allquantifiziert wird, in der restlichen Typsignatur auf Parameter
angewandt wird. Gibt es irgendwo ein solches Vorkommen, wird statt der \texttt{RelAbs} die neue \texttt{RelTypeConsAbs}-Struktur
verwendet.

Von den Parametern her unterscheiden sich die Konstruktoren nicht. Sie werden nur verwendet, damit sie nicht wie normale
Typvariablen verwendet werden. Zum Beispiel macht es keinen Sinn, die Relationsfunktionen zu Typkonstruktorvariablen auf
Funktionen zu spezialisieren. Auch sieht natürlich die resultierende Formel für Typkonstruktorabstraktion anders aus als die
für Typabstraktion.

Da in \texttt{check} bereits abgefangen wird, wenn Typkonstruktorvariablen mit der falschen Zahl an Parametern aufgerufen
werden, kann in \texttt{interpret} davon ausgegangen werden, dass es sich bei einem Vorkommen einer
Applikation von Typvariablen automatisch um eine Typkonstruktorvariable handeln muss.



% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterung von specialise}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Durch Anwenden der Funktion \textit{specialize} wird die Formel des Theorems teilweise stark vereinfacht, da relationale
Aussagen der Form $(x, y) \in \mathcal{R}$ in Gleichungen der Form $f\ x = y$ überführt werden. Es wäre wünschenswert,
diese Vereinfachungen auch für Ausdrücke mit Typkonstruktorvariablen anzuwenden.

In Abschnitt \ref{sec:specialise-relvars} wurde bereits beschrieben, wie \textit{specialise} in \textit{free-theorems} bisher arbeitete.
Es liegt die Vorgehensweise nahe, die bisherige Methode auch auf beliebige Typkonstruktorvariablen auszuweiten. Hier tritt nur leider
das Problem auf, dass man keine Informationen über die konkret verwendete Datenstruktur hat. Alles, was bekannt ist, ist die
verwendete Typklasse, die die Existenz gewisser Funktionen voraussetzt.

Doch selbst wenn diese Funktionen gegeben sind, kann man keine Aussage darüber treffen, was diese Funktionen tun, da
Typklassen Ad-Hoc-Polymorphismus nutzen: Über die tatsächliche Implementierung ist nichts bekannt. Das heißt: Selbst im Falle, dass
die Typvariable auf Instanzen der Typklasse \texttt{Functor} eingeschränkt ist, was bedeutet, dass eine Funktion \texttt{fmap}
existiert, kann man daraus nicht schließen, dass ein Ausdruck der Art $(x, y) \in lift_{Functor}(\mathcal{R})$ auf den Ausdruck
$fmap\ f\ x = y$ spezialisiert werden könnte.

%Eine erste Implementierung sah diesen Ansatz vor, wurde dann aber wieder entfernt.
Eine erste Implementierung sah die Verwendung unterschiedlicher Funktionsnamen vor, abhängig von der Typklasse der
Typkonstruktorvariable. Das folgende Beispiel zeigt das freie Theorem für die Typsignatur \texttt{Functor f => a -> f a}.

\begin{align*}
& \forall t_1, t_2 \in Types, \mathcal{R} : t_1 \Leftrightarrow t_2 \\
& \forall k_1, k_2 \in (* \rightarrow *), \mathcal{K} : k_1 \Leftrightarrow k_2, \mathcal{K}\ \text{respektiert Functor} \\
& \forall (x, y) \in \mathcal{R} . (test_{t_1\ k_1}\ x, test_{t_2\ k_2}\ y) \in \mathcal{K}\ \mathcal{R})
\end{align*}

Spezialisiert man in diesem Beispiel die Relation $\mathcal{R}$ auf eine Funktion $f$, kann man auf die Idee kommen, die letzte
Zeile wie folgt zu transformieren.

\begin{align*}
& \forall x \in t_1 . \text{fmap}\ f\ (test_{t_1 k_1}\ x) = test_{t_2 k_2} (f\ x)
\end{align*}
% TODO: Was ist, wenn Functor-Gesetze gelten?

Aus den oben genannten Gründen muss dies aber nicht immer gelten. Die jeweilige \texttt{fmap}-Funktion könnte beispielsweise
die Reihenfolge der Daten ändern, die übergebene Funktion ignorieren, etc.
Aus diesem Grund wird die Zeile transformiert wie folgt:

\begin{align*}
& \forall x \in t_1 . (test_{t_1 k_1}\ x, test_{t_2 k_2}\ (f\ x)) \in \mathcal{K}\ f
\end{align*}

Da Funktionen spezielle Relationen sind, kann man umgekehrt aus der Funktion $f$ wiederum eine Relation erzeugen, indem
man die Relationsfunktion $\mathcal{K}$ auf $f$ anwendet. Es ist natürlich unglücklich, dass dadurch die Spezialisierung
der Relation prinzipiell wieder ``umgekehrt'' wird und wieder nur eine Aussage über Relationen getroffen wird, andererseits
kann man nicht davon ausgehen, dass jede Funktion, die durch die Relationsfunktion transformiert wird, wieder eine Funktion ist;
man muss also bei der Relationaldarstellung bleiben.

%Hierbei ist $lift_{\mathcal{K}}(f)$ die Relation, die durch das \textit{Lifting} der Funktion $f$ in den $\mathcal{K}$-Kontext
%entsteht. Das ist in diesem Fall notwendig, da $\mathcal{K}$ als Funktion auf Relationen eingeführt wurde. Zwar werden
%Funktionen hier als spezielle Relationen behandelt, rein formal betrachtet kann man an dieser Stelle jedoch nicht
%einfach die Relationsfunktion $\mathcal{K}$ auf eine Funktion $f$ anwenden.

%Die \texttt{specialise}-Funktion überführt an dieser Stelle die \texttt{RelTypeConsApp}-Struktur in eine \texttt{RelLift}-Struktur,
%die eine geliftete Relation darstellt. Normalerweise wird diese Struktur mit einer Angabe darüber gefüllt, um welchen speziellen
%Typkonstruktor es sich handelt, beispielsweise der Listenkonstruktor, der Tupelkonstruktor oder einfach der Name eines
%definierten Datentyps.

%Für den Fall einer Typkonstruktorvariable wurde \texttt{ConVar} als weitere Möglichkeit eingeführt. Diesem Konstruktor wird
%der Name der Typkonstruktorvariablen übergeben \todo{ist das nicht auch einfach nur die relationsfunktion, angewandt auf relation?}


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{asTheorem}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Die Funktion \texttt{asTheorem} wandelt die \texttt{Intermediate}-Darstellung um in eine Formel. Natürlich sind auch hier
Anpassungen vonnöten, um auf vorkommende Typkonstruktorvariablen zu reagieren. Der Datentyp, mit dem Formeln
dargestellt werden, ist \texttt{Formula}. Auch dieser muss um einen Konstruktor für die Allquantifizierung über
Typkonstruktorvariablen erweitert werden, \texttt{ForallTypeConstructors} genannt.
Dieser Konstruktor ist definiert wie der Konstruktor \texttt{ForallRelations}, nur wird er verwendet für die Allquantifizierung
über Relationsfunktionen.

Es gibt zwei neue Fälle zu beachten, was die Transformation von Relationen in Formeln angeht: Zum einen müssen die
entsprechenden Relationsabstraktionen in die neue \texttt{ForallTypeConstructors}-Struktur überführt werden, zum anderen
müssen die Vorkommen von \texttt{RelTypeConsApp} behandelt werden.

Ähnlich wie auch bei anderen Typkonstruktoren, werden angewandte Typkonstruktorvariablen in einen \textit{lift}-Ausdruck
überführt. Folgender Ausdruck sei als Beispiel gegeben.

\begin{align*}
\forall^{\{Functor\}} \mathcal{F} \forall \mathcal{R} . \mathcal{R} \rightarrow \mathcal{F} \mathcal{R}
\end{align*}

Der Ausdruck $\mathcal{F} \mathcal{R}$ aus diesem Beispiel wird als \texttt{Relation}-Struktur dargestellt durch den folgenden
(hier leicht vereinfachten) Haskell-Ausdruck.

\begin{minted}{haskell}
(RelTypeConsApp ("k1 t1", "k2 t2") "F" (RelVar "R"))
\end{minted}

%Die Typausdrücke in Klammern sind die Typen für den gesamten Ausdruck. Zwar handelt es sich hierbei mit \texttt{TypeExpression}
%um einen \texttt{BasicSyntax}-Datentyp, dieser enthält jedoch einen speziellen Typkonstruktor namens \texttt{TypeExp}, mit
%dem beliebige Typen als Zeichenketten dargestellt werden können.

Ähnlich wie Datentypen, die auf eine Typvariable angewandt werden, wird auch die Typkonstruktorvariablenapplikation
behandelt. Zur Erinnerung: Datentypkonstruktoren, angewandt auf allquantifizierte Typvariablen, werden durch eine
\textit{lift}-Funktion als Relation ausgedrückt, deren Definition durch die \texttt{unfoldLifts}-Funktion erzeugt wird.

Bei Typkonstruktorvariablen wird eine solche explizite Lifting-Funktion nicht benötigt, da sie nicht als Relationen repräsentiert
werden, sondern als Funktionen auf Relationen. Da keine weiteren Aussagen zu einem Ausdruck wie $\mathcal{F}\ \mathcal{R}$
gemacht werden können, wird dieser Ausdruck bei Anwendung von \texttt{asTheorem} beibehalten.

Im vorangegangenen Abschnitt wurde gezeigt, dass bei Anwendung von \texttt{specialise} Funktionsvariablenapplikation
durch 

Wie im vorangegangenen Abschnitt bereits erläutert wurde, wird der \texttt{RelTypeConsApp}-Konstruktor bei einer Spezialisierung
zu einem \texttt{RelLift}-Ausdruck, sofern er die entsprechende Relationsvariable beinhaltet, auf die spezialisiert wird.

% TODO: noch ein bisschen genauer!

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Beispieldurchlauf}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Es wurden nun sämtliche Modifikationen an der Bibliothek erläutert, doch um das Zusammenspiel der einzelnen Änderungen
einmal im Zusammenhang zu sehen, wird in diesem Abschnitt ein kompletter Durchlauf für eine Signatur dargestellt, die eine
Typkonstruktorvariable beinhaltet.

%Um die Funktionsweise der Erweiterungen zu verdeutlichen und einen Einblick in die Änderungen zu geben, wird in diesem Abschnitt
%ein kompletter Durchlauf der erweiterten Bibliothek erläutert, wobei sämtliche Zwischendarstellungen der Daten angegeben werden.

Wir verwenden das Beispiel, das bereits in Abschnitt \ref{sec:typkonstruktorklassen} betrachtet wurde.

\begin{minted}{haskell}
fmap :: Functor f => (a -> b) -> f a -> f b
\end{minted}

Dieser Ausdruck wird durch \texttt{parse} in die \texttt{BasicSyntax}-Struktur überführt und es ergibt sich, vereinfacht dargestellt,
der Ausdruck in Listing \ref{lst:fmap-ast}.

\begin{listing}[ht]
\begin{minted}{haskell}
(TypeSig
   (Signature {
      signatureName = (Ident "fmap"),
      signatureType =
         (TypeAbs (TV (Ident "a"))
            []
            (TypeAbs (TV (Ident "b"))
               []
               (TypeAbs (TV (Ident "f"))
                  [(TypeClass (Ident "Functor"))]
                  (TypeFun
                     (TypeFun
                        (TypeVar (TV (Ident "a")))
                        (TypeVar (TV (Ident "b")))
                     )
                     (TypeFun
                        (TypeVarApp (TV (Ident "f"))
                         [(TypeVar (TV (Ident "a")))])
                        (TypeVarApp (TV (Ident "f"))
                        [(TypeVar (TV (Ident "b")))]))
                     ))))}))
\end{minted}
\caption{BasicSyntax-Syntaxbaum für das fmap-Beispiel}
\label{lst:fmap-ast}
\end{listing}

Man kann den neu hinzgekommenen Konstruktor \texttt{TypeVarApp} sehen, der eine Liste von Ausdrücken erwartet, auf
die die entsprechende Typvariable angewandt wird. Zu beachten ist auch, dass auf Syntax-Ebene sowohl Typvariablen als auch
Typkonstruktorvariablen über denselben Ausdruck \texttt{TypeAbs} allquantifiziert werden. Unterschieden wird hier erst im
nächsten Schritt.

Die Liste, die der \texttt{TypeAbs}-Konstruktor als zweiten Parameter erwartet, ist die Liste der Einschränkungen -- auf Syntaxebene
sind dies die im Kontext angegebenen Typklassen.

Der nächste Schritt besteht wieder darin, die Funktion $interpret$ aufzurufen. Was im Beispiel nicht zu sehen ist, ist die
Deklaration der \texttt{Functor}-Klasse. Natürlich muss die $interpret$-Funktion wissen, welche vordefinierten Funktionen,
Datentypen und Klassen gegeben sind. In der Implementierung der Webui \cite{freetheoremswebui} werden zum Beispiel bereits
geparste BasicSyntax-Ausdrücke vieler Deklarationen der Prelude aus einem separaten Modul importiert und der
\texttt{interpret}-Funktion zusätzlich zur eigentlichen Signatur übergeben, sodass sie dieser bekannt sind.
Außerdem wird ein Eingabefeld angezeigt, in dem es möglich ist, zusätzliche Deklarationen anzugeben.

Wir gehen im Folgenden davon aus, dass die typische Deklaration der \texttt{Functor}-Klasse gegeben ist, wie sie auch schon
mehrfach verwendet wurde in dieser Arbeit. \todo{?} \texttt{interpret} überführt die \texttt{BasicSyntax} nun also in die
\texttt{Intermediate}-Darstellung, die im Folgenden zu sehen ist.

\begin{minted}{haskell}
(Intermediate "fmap" BasicSubset
   (RelAbs "R" ("t1", "t2")
      (RelAbs "S" ("t3", "t4")
         (RelTypeConsAbs ("k1", "k2")
            (RelFun
               (RelFun
                  (RelVar "R")
                  (RelVar "S"))
                  (RelFun
                     (RelTypeConsApp ("k1 t1", "k2 t2") "R1" (RelVar "R"))
                     (RelTypeConsApp ("k1 t3", "k2 t4") "R1" (RelVar "S"))
                  ))))) ...)
\end{minted}

Dieser Schritt ist wieder relativ selbsterklärend, da lediglich jede Typkonstruktion in die entsprechende Relationskonstruktion
überführt wird. Die \texttt{RelTypeConsApp}-Ausdrücke entsprechen dabei der Applikation einer Relationsfunktion auf
eine Relation. Die Typen sind dabei die Typkonstruktoren, angewandt auf die Typvariablen.

% TODO: Beispieldurchlauf zuende schreiben