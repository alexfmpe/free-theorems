% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Erweiterung um Typkonstruktorklassen}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\label{sec:erweiterung-um-typklassen}

In den bisherigen Abschnitten wurden die Grundlagen zu freien Theoremen erklärt, es wurde erläutert, wie freie Theoreme
aussehen, wenn Typkonstruktorklassen eine Rolle spielen, und es wurde ein Einblick in die Bibliothek \textit{free-theorems}
gegeben. Es sind jetzt alle Werkzeuge vorhanden, um die Bibliothek so zu erweitern, dass auch Typkonstruktorklassen möglich
sind, deren Typparameter die Sorte $* \rightarrow *$ haben. Und natürlich muss es möglich sein, Typsignaturen zu schreiben,
in denen Typvariablen auf solche Klassen beschränkt und auf Typparameter angewandt werden.

Dieses Kapitel ist ähnlich gegliedert wie Kapitel \ref{sec:free-theorems}: Die einzelnen Abschnitte entsprechen den Funktionen,
die bei der Verwendung der Bibliothek durchlaufen werden. Dabei wird jeweils erläutert, inwiefern sich Funktionsweisen ändern
bzw. neue Funktionalitäten hinzugefügt werden. Insbesondere wird ein Blick auf die internen Datenstrukturen gegeben,
die hier eine Rolle spielen.
%Dieses Kapitel ist aufgeteilt in die verschiedenen Schritte, die bei der Verwendung der Bibliothek durchlaufen werden. Es
%wird jeweils darauf eingegangen, welche Änderungen notwendig sind und was jeweils zu beachten ist, um Typkonstruktorklassen
%zu unterstützen.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterungen der BasicSyntax}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Alles beginnt bei der Syntax. Der Zweck der vereinfachten \texttt{BasicSyntax} war, dass nicht verwendete Sprachkonstrukte
ignoriert werden können. Typvariablen, die auf andere Typen angewandt werden, gehörten bisher zu diesen vernachlässigbaren
Konstrukten. Da im Hintergrund aber ein kompletter Haskell-Parser arbeitet, lässt sich diese Erweiterung relativ einfach
wieder einpflegen.

Rein syntaktisch kann man Typkonstruktorvariablen sehen als Typvariablen, die wie Typkonstruktoren verwendet werden. Das
soll im folgenden Beispiel verdeutlicht werden.

%Bevor man mit Typkonstruktorvariablen arbeiten kann, müssen diese natürlich zunächst in der \texttt{BasicSyntax} vorgesehen
%sein. An sich verhalten sich diese ja wie andere Typvariablen auch, mit dem Unterschied, dass sie - ähnlich wie Funktionen -
%auf andere Typausdrücke angewandt werden können. Das folgende Beispiel soll dies verdeutlichen.

\begin{minted}{haskell}
test :: Monad m => m a -> (a -> m b) -> m b
\end{minted}

Das Beispiel zeigt die Signatur der Funktion \texttt{test}, in der die freie Typvariable \texttt{f} auf die Klasse \texttt{Monad}
eingeschränkt wird. Diese Klasse ist so definiert, dass sie einen Typparameter erwartet, der von der Sorte $* \rightarrow *$ ist,
folglich also selbst einen Parameter erwartet. Dementsprechend kommt in der Signatur beispielsweise der Ausdruck \texttt{f a} vor,
d.h. die Typkonstruktorvariable \texttt{f} wird angewandt auf die Typvariable \texttt{a}.

Es ist noch zu beachten, dass eine solche Applikation bei bestimmten Standardtypkonstruktoren bereits vorgesehen ist, diese
haben mit Typvariablenapplikation aber nichts zu tun. So sind \texttt{[a]} und \texttt{Maybe a} bereits möglich. Da es sich
bei \texttt{[]} und \texttt{Maybe} jedoch nicht um Variablen handelt, sondern um bekannte Typkonstruktoren, wird hier auch ein
anderer Datentyp verwendet.

Um also dieser neuen syntaktischen Möglichkeit Rechnung zu tragen, wird die \texttt{BasicSyntax} um den Konstruktor
\texttt{TypeVarApp} erweitert. Am besten wird das deutlich, wenn man betrachtet, in welchen Ausdruck das obige Beispiel
in \texttt{BasicSyntax} überführt wird - siehe hierzu Listing \ref{lst:typevarapp}.

\begin{listing}[ht]
\inputminted[tabsize=2]{haskell}{typevarapp.hs}
\caption{Beispielsignatur von test in BasicSyntax-Struktur}
\label{lst:typevarapp}
\end{listing}

Damit ist bereits die einzige benötigte Syntaxänderung eingeführt, da Klassendeklarationen bereits möglich sind. Innerhalb der
Klassendeklaration muss Variablenapplikation natürlich auch möglich sein. Das ist aber automatisch möglich, da sich die Änderungen
auf sämtliche Funktionssignaturen erstrecken, unabhängig ob Toplevel-Signaturen oder Signaturen von Klassenfunktionen.

%Da Typvariablenapplikation in \cite{freetheorems} nicht vorgesehen ist, musste ein solches Konstrukt in die BasicSyntax-Struktur eingefügt werden. Hierbei ist zu beachten: Die Applikation
%von Standardtypkonstruktoren, beispielsweise \texttt{[a]} für Listen, ist sehr wohl vorgesehen und wird in der BasicSyntax durch \texttt{TypeCon} im Datentyp \texttt{TypeExpression} dargestellt. \todo{Wahrscheinlich viel zu speziell} Diese Standardtypkonstruktoren werden in diesem Zusammenhang aber als Sonderfälle betrachtet \ref{sec:freie-theoreme}, um das System wirklich um eigene Typklassen zu erweitern, muss es auch möglich sein, Typkonstruktorvariablen auf Typen anzuwenden.
%
%Die Erweiterung der BasicSyntax sieht hier so aus, dass ein neuer Konstruktor \texttt{TypeVarApp} zum Datentypen \texttt{TypeExpression} hinzugefügt wird. In Listing \ref{lst:typevarapp} ist ein Beispiel zu sehen.
%
%\inputminted[tabsize=2]{haskell}{typevarapp.hs}
%
%Abgesehen vom offensichtlichen Problem, dass dieser Konstruktor bei der Theoremgenerierung zu Fehlern beim Pattern Matching oder zumindest zu unerwünschtem Verhalten führt,
%ist auch zu beachten, dass die in Abschnitt \ref{sec:check} erwähnte \texttt{check}-Funktion entsprechend angepasst wird.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterung von Relation}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

% Da eine neue Relationskonstruktion eingeführt wird, muss auch der entsprechende Datentyp angepasst werden.
Der abstrakte Syntaxbaum in der \texttt{BasicSyntax}-Struktur wird von der \textit{interpret}-Funktion in eine relationale
Darstellung überführt. Das folgende Beispiel beinhaltet zur Verdeutlichung ein explizites \texttt{forall}.

\begin{minted}{haskell}
test :: forall a. a -> a
\end{minted}

Die Typsignatur dieses Beispiels lässt sich als Relation $\forall \mathcal{R}. \mathcal{R} \rightarrow \mathcal{R}$ auffassen.
Dabei ist $\forall \mathcal{R}. \mathcal{A}(\mathcal{R})$ so definiert, dass über alle Relationen aller Typmengen allquantifiziert
wird (vgl. Abschnitt \ref{sec:free-theorems-param}). \todo{richtig so?} So weit ist das Vorgehen bereits bekannt und auch schon
in \textit{free-theorems} implementiert.

Interessant ist nun, wie es sich verhält, wenn eine solche Typvariable auf Typausdrücke angewandt wird, wie das folgende
Beispiel zeigt.

\begin{minted}{haskell}
test :: forall f a. Functor f => f a -> f a
\end{minted}

Dieses Beispiel wird überführt in $\forall^{\{Functor\}} \mathcal{F} \forall \mathcal{R}. \mathcal{F} \mathcal{R} \rightarrow
\mathcal{F} \mathcal{R}$, wobei $\mathcal{F}$ \textit{keine} Relation ist. Es handelt sich hierbei, im Gegensatz zu $\mathcal{R}$ aus
dem ersten Beispiel, um eine Fuktion, die eine Relation auf eine andere Relation abbildet. Es wird hier also auch nicht über
Relationen allquantifiziert, sondern über entsprechende Funktionen, was bedeutet, dass es sich um eine andere Konstruktion
handelt als die Allquantifizierung über einfache Typvariablen.

Dieser Argumentation folgend wird ein zusätzlicher Konstruktor eingeführt für die Typkonstruktorabstraktion, der
\texttt{RelTypeConsAbs} genannt wird. Außerdem wird der Konstruktor \texttt{RelTypeConsApp} eingeführt, der benutzt
wird, wenn man eine Relationsfunktion auf eine Relation anwendet, im obigen Beispiel also $\mathcal{F} \mathcal{R}$.

Tabellen \ref{tab:reltypeconsabs} und \ref{tab:reltypeconsapp} zeigen die Parameter für diese neuen Datentypkonstruktoren.

\begin{table}[th]
\begin{tabular}{ | l | l | }
\hline
RelTypeConsAbs & \\
\hline
\texttt{RelationInfo} & Zusätzliche Informationen zur Relation, in jedem Konstruktor \\
& enthalten. \\
\texttt{RelationVariable} & Funktionsvariable, die allquantifiziert wird. \\
\texttt{(TypeExpression,} & Funktionsvariablen auf der linken und rechten Seite. \\
\texttt{TypeExpression)} & \\
\texttt{[Restriction]} & Einschränkungen auf Klassen, aber auch auf \textit{Striktheit},\\
& \textit{Stetigkeit}, etc. \\
\texttt{Relation} & Die Relation, die die quantifizierte Variable enthält. \\
\hline
\end{tabular}
\caption{Parameter des Konstrktors \texttt{RealConsAbs}}
\label{tab:reltypeconsabs}
\end{table}

\begin{table}[th]
\begin{tabular}{ | l | l | }
\hline
RelTypeConsApp & \\
\hline
\texttt{RelationInfo} & Zusätzliche Informationen zur Relation, in jedem Konstruktor \\
& enthalten. \\
\texttt{RelationVariable} & Relationsfunktionsvariable, die auf eine Relation angewandt\\
& wird. \\
\texttt{Relation} & Relation, auf die die Typkonstruktorfunktion angewandt wird. \\
\hline
\end{tabular}
\caption{Parameterliste des Konstruktors \texttt{RealConsApp}}
\label{tab:reltypeconsapp}
\end{table}

Mit diesen Erweiterungen ist es möglich, die hinzukommenden relationalen Strukturen auszudrücken.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterung von check}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

%Da in der ursprünglichen Version von free-theorems Typkonstruktorvariablen nicht gestattet waren, konnten einige
%Fehlerüberprüfungen eingespart werden. Erlaubt man Typkonstruktorvariablen, muss man zusätzliche Fehlerfälle abdecken,
%die auftreten können. Betrachten wir das folgende Beispiel:

In der ursprünglichen Version von \textit{free-theorems} können Typkonstruktorvariablen nicht verwendet werden. Es wird eine
Fehlermeldung ausgegeben, sobald eine Typvariable auf eine andere angewandt wird. Gestattet man dies, müssen neu
entstehende Problemfälle abgedeckt werden.

Das folgende Beispiel zeigt ein solches Problem.

\begin{minted}{haskell}
test :: Functor f => f a -> f
\end{minted}

Hierbei handelt es sich nicht um eine korrekte Haskell-Typsignatur: Die Variable f wird als Functor eingeführt und in der Signatur
einmal mit einem Parameter, einmal ohne Parameter aufgerufen. Selbst wenn man die Deklaration von Functor außer Acht lässt,
kann man deutlich sehen, dass eine der beiden Vorkommen von \texttt{f} fehlerhaft ist. \texttt{f} erwartet entweder einen
oder gar keinen Parameter, unterschiedliche Parameterzahlen sind nicht gestattet.

Da Functor bekannt ist, kann man einfach die Deklaration dieser Klasse betrachten:

\begin{minted}{haskell}
class Functor f where
   fmap :: (a -> b) -> f a -> f b
\end{minted}

Anhand der Deklaration der Klassenfunktionen kann man nun sehen, dass die Variable \texttt{f} stets auf einen einzelnen 
Parameter angewandt wird, das heißt, man kann bei allen Vorkommen der Klasse Functor davon ausgehen, dass diese
auf genau einen Parameter appliziert werden müssen. Natürlich kommt hier eine weitere Überprüfung ins Spiel: Es muss
sichergestellt werden, dass die Klassenvariable - in diesem Fall f - in sämtlichen Klassenfunktionen mit der gleichen Anzahl an
Parametern verwendet werden.

Die Überprüfung innerhalb einer Klasse auf gleiche Arität aller Vorkommen der Klassenvariable ist eine lokale Überprüfung -
es wird stets nur die Klassendeklaration benötigt, ein globaler Kontext muss nicht bekannt sein. Möchte man überprüfen,
ob Typkonstruktorvariablen in beliebigen Deklarationen die korrekte Anzahl an Parametern haben, dann muss man den
globalen Kontext betrachten: Die Deklaration der Klasse muss in Betracht gezogen werden.

Eine Besonderheit ist hierbei auch, dass eine Typvariable auf mehrere Klassen gleichzeitig eingeschränkt werden kann. So ist
das folgende Beispiel legitimer Haksell-Code:

\begin{minted}{haskell}
test :: (SomeClass1 f, SomeClass2 f) => f a -> f b
\end{minted}

%Man muss also zusätzlich sicherstellen, dass alle Klassen, die für die gleichen Variablen angegeben sind, die gleiche Anzahl an
%Parametern erwarten.

Es muss also sichergestellt werden, dass alle Klassen, die pro Variable angegeben sind, die gleiche Anzahl an Parametern erwarten.
Dieses Problem erledigt sich allerdings automatisch, wenn man die rechte Seite auf Fehler überprüft, da im Falle unterschiedlicher
Aritäten mindestens einer der beiden Ausdrücke \texttt{f a} und \texttt{f b} einen Fehler erzeugen würde.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterung von interpret}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Die \texttt{interpret}-Funktion ist dafür zuständig, den abstrakten Syntaxbaum von Typsignaturen in die enstprechende
\texttt{Intermediate}-Struktur zu überführen. Natürlich sind hier Änderungen notwendig, wenn \texttt{interpret} auch
Typkonsturktorvariablen und deren Applikation erkennen und korrekt behandeln soll.

Es wurde ja bereits in Abschnitt \ref{sec:free-theorems-interpret} erläutert, wie die Funktion mit dem \textit{forall}-Konstrukt
umgeht: Es wird in eine Allquantifizierung über Relationen umgewandelt, also in einen \texttt{RelAbs}-Ausdruck.
Da es sich hierbei nicht mehr zwingend um Relationen handelt, wenn Typkonstruktorvariablen vorkommen können, sondern auch
Funktionen auf Relationen afutreten können, wird jetzt an dieser Stelle eine Fallunterscheidung eingebaut.

Es wird überprüft, ob die entsprechende Typvariable, über die allquantifiziert wird, in der restlichen Typsignatur auf Parameter
angewandt wird. Gibt es irgendwo ein solches Vorkommen, wird statt der \texttt{RelAbs} die neue \texttt{RelTypeConsAbs}-Struktur
verwendet.

Von den Parametern her unterscheiden sich die Konstruktoren nicht. Sie werden nur verwendet, damit sie nicht wie normale
Typvariablen verwendet werden. Zum Beispiel macht es keinen Sinn, die Relationsfunktionen zu Typkonstruktorvariablen auf
Funktionen zu spezialisieren. Auch sieht natürlich die resultierende Formel für Typkonstruktorabstraktion anders aus als die
für Typabstraktion.

Da in \texttt{check} bereits abgefangen wird, wenn Typkonstruktorvariablen mit der falschen Zahl an Parametern aufgerufen
werden, kann in \texttt{interpret} davon ausgegangen werden, dass es sich bei einem Vorkommen einer
Applikation von Typvariablen automatisch um eine Typkonstruktorvariable handeln muss.



% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Erweiterung von specialise}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Durch Anwenden der Funktion \textit{specialize} wird die Formel des Theorems teilweise stark vereinfacht, da relationale
Aussagen der Form $(x, y) \in \mathcal{R}$ in Gleichungen der Form $f\ x = y$ überführt werden. Es wäre wünschenswert,
diese Vereinfachungen auch für Ausdrücke mit Typkonstruktorvariablen anzuwenden.

In Abschnitt \ref{sec:specialise-relvars} wurde bereits beschrieben, wie \textit{specialise} in \textit{free-theorems} bisher arbeitete.
Es liegt die Vorgehensweise nahe, die bisherige Methode auch auf beliebige Typkonstruktorvariablen auszuweiten. Hier tritt nur leider
das Problem auf, dass man keine Informationen über die konkret verwendete Datenstruktur hat. Alles, was bekannt ist, ist die
verwendete Typklasse, die die Existenz gewisser Funktionen voraussetzt.

Doch selbst wenn diese Funktionen gegeben sind, kann man keine Aussage darüber treffen, was diese Funktionen tun, da
Typklassen Ad-Hoc-Polymorphismus nutzen: Über die tatsächliche Implementierung ist nichts bekannt. Das heißt: Selbst im Falle, dass
die Typvariable auf Instanzen der Typklasse \texttt{Functor} eingeschränkt ist, was bedeutet, dass eine Funktion \texttt{fmap}
existiert, kann man daraus nicht schließen, dass ein Ausdruck der Art $(x, y) \in lift_{Functor}(\mathcal{R})$ auf den Ausdruck
$fmap\ f\ x = y$ spezialisiert werden könnte.

%Eine erste Implementierung sah diesen Ansatz vor, wurde dann aber wieder entfernt.
Eine erste Implementierung sah die Verwendung unterschiedlicher Funktionsnamen vor, abhängig von der Typklasse der
Typkonstruktorvariable. Das folgende Beispiel zeigt das freie Theorem für die Typsignatur \texttt{Functor f => a -> f a}.

\begin{align*}
& \forall t_1, t_2 \in Types, \mathcal{R} : t_1 \Leftrightarrow t_2 \\
& \forall k_1, k_2 \in (* \rightarrow *), \mathcal{K} : k_1 \Leftrightarrow k_2, \mathcal{K}\ \text{respektiert Functor} \\
& \forall (x, y) \in \mathcal{R} . (test_{t_1\ k_1}\ x, test_{t_2\ k_2}\ y) \in \mathcal{K}\ \mathcal{R})
\end{align*}

Spezialisiert man in diesem Beispiel die Relation $\mathcal{R}$ auf eine Funktion $f$, kann man eben auf die Idee kommen, die letzte
Zeile wie folgt zu transformieren.

\begin{align*}
& \forall x \in t_1 . \text{fmap}\ f\ (test_{t_1 k_1}\ x) = test_{t_2 k_2} (f\ x)
\end{align*}
% TODO: Was ist, wenn Functor-Gesetze gelten?

Aus den oben genannten Gründen muss dies aber nicht immer gelten. Die jeweilige \texttt{fmap}-Funktion könnte beispielsweise
die Reihenfolge der Daten ändern, die übergebene Funktion ignorieren, etc.
Aus diesem Grund wird die Zeile transformiert wie folgt:

\begin{align*}
& \forall x \in t_1 . (test_{t_1 k_1}\ x, test_{t_2 k_2}\ (f\ x)) \in lift_{\mathcal{K}}(f)
\end{align*}

Hierbei ist $lift_{\mathcal{K}}(f)$ die Relation, die durch das \textit{Lifting} der Funktion $f$ in den $\mathcal{K}$-Kontext
entsteht.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{asTheorem}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Die Funktion \texttt{asTheorem} wandelt die \texttt{Intermediate}-Darstellung um in eine Formel. Natürlich sind auch hier
Anpassungen vonnöten, um auf vorkommende Typkonstruktorvariablen zu reagieren. Der Datentyp, mit dem Formeln
dargestellt werden, ist \texttt{Formula}. Auch dieser muss um einen Konstruktor für die Allquantifizierung über
Typkonstruktorvariablen erweitert werden, \texttt{ForallTypeConstructors} genannt.
Dieser Konstruktor ist definiert wie der Konstruktor \texttt{ForallRelations}, nur wird er verwendet für die Allquantifizierung
über Relationsfunktionen.

Es gibt zwei neue Fälle zu beachten, was die Transformation von Relationen in Formeln angeht: Zum einen müssen die
entsprechenden Relationsabstraktionen in die neue \texttt{ForallTypeConstructors}-Struktur überführt werden, zum anderen
müssen die Vorkommen von \texttt{RelTypeConsApp} behandelt werden.

Ähnlich wie auch bei anderen Typkonstruktoren, werden angewandte Typkonstruktorvariablen in einen \textit{lift}-Ausdruck
überführt. Folgender Ausdruck sei als Beispiel gegeben.

\begin{align*}
\forall^{\{Functor\}} \mathcal{F} \forall \mathcal{R} . \mathcal{R} \rightarrow \mathcal{F} \mathcal{R}
\end{align*}

Der Ausdruck $\mathcal{F} \mathcal{R}$ aus diesem Beispiel wird als \texttt{Relation}-Struktur dargestellt durch den folgenden
(hier leicht vereinfachten) Haskell-Ausdruck.

\begin{minted}{haskell}
(RelTypeConsApp ("k1 t1", "k2 t2") "F" (RelVar "R"))
\end{minted}

Dieser Ausdruck wird nun überführt in ...


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Beispieldurchlauf}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Um die Funktionsweise der Erweiterungen zu verdeutlichen und einen Einblick in die Änderungen zu geben, wird in diesem Abschnitt
ein kompletter Durchlauf der erweiterten Bibliothek erläutert, wobei sämtliche Zwischendarstellungen der Daten angegeben werden.

Wir verwenden dabei das Beispiel, das bereits in Abschnitt \ref{sec:typkonstruktorklassen} betrachtet wurde.

\begin{minted}{haskell}
fmap :: Functor f => (a -> b) -> f a -> f b
\end{minted}

% TODO: Beispieldurchlauf zuende schreiben