% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Grundlagen}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\label{sec:grundlagen}

Bevor auf die eigentliche Thematik eingegangen wird, bietet es sich an, einige Grundlagen zu klären, die im Laufe dieser Arbeit
von Bedeutung sein werden. Ein großer Teil der Arbeit baut auf dem mathematischen Konstrukt der Relation auf, weshalb neben
grundsätzlichen mathematischen Notationen vor allem Definitionen und Notationen eingeführt werden, die Relationen betreffen.

Des Weiteren sind Haskell-Kenntnisse erforderlich. Es würde an dieser Stelle zu weit führen, sämtliche Sprachkonstrukte von
Haskell anzuführen, die für die folgenden Abschnitte von Bedeutung sind; dennoch wird zumindest auf Typklassen eingegangen, insbesondere Typkonstruktorklassen,
da diese für die Arbeit eine signifikante Rolle spielen. Zudem bietet es sich an, von Anfang an einige Benennungen einzuführen, die im Laufe der
Arbeit immer wieder auftauchen werden.

%Sämtliche sprachliche Konstrukte von
%Haskell zu erläutern, die im Laufe dieser Arbeit erscheinen, würde an dieser Stelle zu weit führen. Es wird aber auf das Konstrukt
%der Typklassen, insbesondere der Typkonstruktorklassen, eingegangen, da diese im weiteren Verlauf der Ausarbeitung eine
%signifikante Rolle spielen. Zudem bietet es sich an, von Anfang an einige Benennungen einzuführen, die im Laufe der Arbeit
%immer wieder gebraucht werden.

%Es soll hier nicht darum gehen,
%die komplette Programmiersprache Haskell zu beschreiben, aber es wird auf das Konzept der Typkonstruktorklassen eingegangen, da diese
%in dieser Ausarbeitung eine gesonderte Rolle spielen.

%In diesem Abschnitt sollen einige Grundlagen eingeführt werden, die in den folgenden Kapiteln von Bedeutung sind. Zunächst werden
%einige mathematische Definitionen und Notationen angegeben, die zum großen Teil Relationen betreffen.
%Daraufhin wird noch einmal kurz auf Typklassen in Haskell eingegangen.

%Da diese Arbeit zu großen Teilen auf \cite{freetheorems} aufbaut, werden die dort verwendeten Notationen größtenteils
%weiter verwendet.

%Die mathematischen Notationen in diesem Kapitel halten sich größtenteils an die Darstellungen von Böhme in \cite{freetheorems}

%Die in diesem Abschnitt
%eingeführten Notationen orientieren sich größtenteils an den Definitionen aus \cite{freetheorems}.

%Die Notationen, die hier eingeführt werden, bauen größtenteils auf \cite{freetheorems} auf, da die dort beschriebene Bibliothek
%die Grundlage für die vorliegende Arbeit darstellt.


% % % % %% % % % % % % % % % % %


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Relationen}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Die mathematische Grundlage und das wichtigste Werkzeug beim Erzeugen von freien Theoremen sind Relationen.

%Sie werden im Zusammenhang mit freien Theoremen verwendet, um Ausdrücke einander zuzuordnen, die durch Polymorphie einander
%ähnlich bzw. ``austauschbar'' sind.

Eine \textit{binäre Relation} ist auf zwei Mengen definiert, deren Elemente sie einander zuordnet. Die Schreibweise
$\mathcal{R} : T_1 \Leftrightarrow T_2$ sagt, dass $\mathcal{R}$ eine auf den Mengen $T_1$ und $T_2$ definierte
Relation ist. Man kann die Relation als eine Menge von Paaren auffassen, wobei jedes Paar aus einem Element aus $T_1$ und einem
Element aus $T_2$ besteht.
%Sie ordnet den Elementen der ersten Menge beliebig viele Elemente der zweiten Menge zu. Man kann die Relation
%auffassen als eine Menge von Paaren, wobei jedes Paar aus einem Element aus $T_1$ und einem Element aus $T_2$ besteht.

\begin{align*}
T_1 \times T_2 \subseteq \mathcal{R}
\end{align*}

Die Aussage $(x, y) \in \mathcal{R}$ bedeutet also, dass $x$ und $y$ bezüglich $\mathcal{R}$ verwandt sind. Man schreibt hierfür
gelegentlich auch $x\ \mathcal{R}\ y$ (hauptsächlich, wenn es sich bei $\mathcal{R}$ um ein Operatorsymbol handelt).
Anders ausgedrückt ordnet eine Relation jedem Element aus der ersten Menge beliebig viele Elemente aus der zweiten Menge zu.

% % % % % Nicht zwingend drin % % % % %

\todo{Hiervon brauche ich wahrscheinlich nicht alles}
%Zunächst werden die grundlegenden Notationen behandelt.
Ist $X$ eine Menge, dann ist durch $\mathcal{P}(X)$ die Potenzmenge von $X$ gegeben, bei der es sich um die Menge handelt, die alle Teilmengen von $X$ beinhaltet.

%Eine \textit{gerankte} Menge \todo{Wie soll man ranked übersetzen?} ist ein Paar $(A, rank)$, wobei $A$ eine endliche Menge ist und
%$rank : A \rightarrow \mathbb{N}$ eine Funktion, die jedem Element der Menge einen Rang zuordnet. Man bezeichnet mit
%$A^{(n)}$ die Menge $\{a \in A | rank(a) = n \}$, $n \in \mathbb{N}$.

Eine partielle Ordnung $\sqsubseteq : M \Leftrightarrow M$ ist eine Relation, die \textit{reflexiv}, \textit{antisymmetrisch} und \textit{transitiv} ist, d.h. es gelten die folgenden Aussagen für alle $x, y, z \in M$.

\begin{align*}
& x \sqsubseteq x & \text{(Reflexivität)} \\
& x \sqsubseteq y \land y \sqsubseteq x \Rightarrow x = y & \text{(Antisymmetrie)} \\
& x \sqsubseteq y \land y \sqsubseteq z \Rightarrow x \sqsubseteq z & \text{(Transitivität)} \\
\end{align*}

Sei X eine Menge und $\sqsubseteq_{X}$ eine partielle Ordnung über X. Man nennt eine Funktion $\bar{x} : \mathbb{N} \rightarrow X$
eine \textit{monotone Sequenz} über $X$, wenn $\bar{x}(i) \sqsubseteq_{X} \bar{x}(i + 1)$ für alle $i \in \mathbb{N}$.

Wenn $\sqsubseteq_{X}$ ein kleinstes Element besitzt, dann ist $\sqsubseteq_{X}$ eine komplette Partialordnung und man nennt $X$
\textit{geordnet}. Dieses kleinste Element wird typischweise als $\bot_{X}$ (\textit{bottom}) bezeichnet.

Sei $\mathcal{R} \subseteq X \times Y$ eine binäre Relation über zwei geordneten Mengen $X$ und $Y$. Man nennt $\mathcal{R}$ \textit{strikt},
wenn $(\bot, \bot) \in \mathcal{R}$. $\mathcal{R}$ wird \textit{total} genannt, wenn für jedes Paar $(x, y) \in \mathcal{R}$ gilt, dass
aus $y = \bot$ folgt $x = \bot$.

Man nennt $\mathcal{R}$ \textit{bottom-reflecting} \todo{wie soll man das bloß übersetzen?}, wenn sogar für jedes Paar
$(x, y) \in \mathcal{R}$ gilt: $y = \bot \Leftrightarrow x = \bot$.

Wenn für alle monotonen Sequenzen $\bar{x}$ über $X$ und $\bar{y}$ über $Y$, die $(\bar{x}(i), \bar{y}(i)) \in \mathcal{R}$
erfüllen, jeweils das Paar der Suprema ($\bigsqcup{\bar{x}}, \bigsqcup{\bar{y}})$ in $\mathcal{R}$ ist, dann nennt man $\mathcal{R}$ \textit{stetig}. Eine Relation ist \textit{zulässig}, wenn sie strikt und stetig ist.

Sind drei Mengen $X$, $Y$ und $Z$ und zwei binäre Relationen $\mathcal{R} \subseteq X \times Y$ und $\mathcal{R} \subseteq Y
\times Z$ gegeben, dann definiert man die \textit{Komposition} von $\mathcal{R}$ und $\mathcal{S}$,
geschrieben $\mathcal{R} ; \mathcal{S}$, wie folgt.

\begin{align*}
\mathcal{R} ; \mathcal{S} = \{ (x, z) | \exists y \in Y . (x, y) \in \mathcal{R} \and (y, z) \in \mathcal{S} \} \subseteq X \times Z
\end{align*}

Ist Y eine Menge und X eine bezüglich $\sqsubseteq_{X}$ geordnete Menge, dann nennt man eine Relation $\mathcal{R} \subseteq X \times Y$ \textit{links-abgeschlossen},
\todo{Übersetzung?} wenn $\sqsubseteq_{X} ; R = R$.

Das Inverse einer Relation $\mathcal{R} \subseteq X \times Y$ wird definiert als $\mathcal{R}^{-1} = \{(y, x) | (x, y) \in \mathcal{R}\}
\subseteq Y \times X$. Möchte man $\sqsubseteq^{-1}$ ausdrücken, nutzt man zuweilen auch das umgedrehte Symbol $\sqsupseteq$.

Seien $X$ und $Y$ geordnete Mengen und $f : X \rightarrow Y$ eine Funktion. Man nennt $f$ \textit{monoton}, wenn aus $x \sqsubseteq y$ folgt, dass
$f(x) \sqsubseteq f(y)$ für alle $x, y \in X$.

%Sei $V$ eine endliche Menge und $\mathcal{E}$ eine binäre Relation auf $V$. Das Tupel $G = (V, \mathcal{E}) bezeichnet einen
%\textit{gerichteten Graphen}. Die Elemente von $V$ nennt man \textit{Vertices}. Die transitive Hülle von $E$ bezeichnet man mit
%$\mathcal{E}^{+}$. Sei $V_c = \{ v \in V | (v, v) } \in \mathcal{E}^{+} \} die Menge aller Vertizes, die Teil eines Kreises sind.
%
%Für je zwei Teilmengen $V_1, V_2 \subseteq V$, bezeichnet die Menge $R(V_1, V_2) = \{ v_2 \in V_2 | \exists v_1 \in V_1. (v_1, v_2) \in
%\mathcal{E}^{+} \} alle Vertices in $V_2$, die von einem Vertex aus $V_1$ aus erreichbar sind.Wenn $V'$ eine Teilmenge von $V$ ist,
%dann ist die Menge $V' \backslash R(V \backslash V', V') 
% % % % % % % % % % % % % % % % %

%\subsubsection{Relationen und Funktionen}
%`````````````````````````````````

Wie bereits erwähnt, ordnet eine Relation einem Element ein einzelnes Element, mehrere Elemente oder gar keine Elemente zu.
Das unterscheidet sie von einer Funktion, oder anders ausgedrückt: Das macht Funktionen zu speziellen Relationen. Eine
Funktion, ebenfalls auf zwei Mengen definiert, ordnet jedem Element genau ein Ergebnis zu - Eingabewerte mit
mehreren Funktionswerten sind genausowenig enthalten wie Eingabewerte ohne Ergebnis.

Wir betrachten eine beliebige Funktion $f : T_1 \rightarrow T_2$. Zu jedem $x \in T_1$ ist also $f(x)$ definiert, wobei $f(x) \in T_2$. Funktionen kann man auch wie folgt als Relationen darstellen.

\begin{align*}
\{ (x, f(x)) | x \in T_1 \}
\end{align*}

Man nennt die zu $f$ gehörige Relation auch den \textit{Graphen} zu $f$.

Umgekehrt heißt das natürlich, dass eine Relation unter Umständen auch eine Funktion ist. Das wird besonders interessant, wenn man
über Relationen allquantifiziert, beispielsweise $\forall \mathcal{R} : T_1 \Leftrightarrow T_2 . A(\mathcal{R})$, wobei $A(\mathcal{R})$
eine Aussage ist, die von $\mathcal{R}$ abhängt.
Diese Aussage lässt sich verschärfen, indem man statt über Relationen über Funktionen $\forall f : T_1 \rightarrow T_2$ quantifiziert.
Eine Aussage wie  $(x, y) \in \mathcal{R}$ wird dann beispielsweise zu $f\ x = y$.

Man kann sich leicht klar machen, dass eine solche spezialisierte Aussage aus der ursprünglichen Aussage folgt. Gilt die ursprüngliche
Aussage, gilt dementsprechend auch die speziellere Aussage.

%Andererseits bedeutet das, dass es Relationen gibt, die man auch als Funktionen auffassen kann. Hat man beispielsweise
%eine Aussage über beliebige Relationen $\forall \mathcal{R} : T_1 \Leftrightarrow T_2 . A(\mathcal{R})$, wobei A eine
%Aussage ist, die von $\mathcal{R}$ abhängig ist, dann macht es Sinn, aus dieser Aussage eine speziellere Aussage zu folgern,
%die wie folgt aussieht.
%
%\begin{align*}
%\forall f : T_1 \rightarrow T_2 . A'(f)
%\end{align*}
%
%Hierbei ist A'(f) die auf Funktionen spezialisierte Aussage. Aus jeder Aussage über beliebige Relationen folgt also eine
%Aussage über entsprechende Funktionen. Dies ist für freie Theoreme von Bedeutung, da man sich vor allem für eine vereinfachte
%Darstellung mit Funktionen interessiert.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Haskell}
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Die in dieser Ausarbeitung verwendete Bibliothek generiert freie Theoreme für in Haskell geschriebene Programme. In diesem Abschnitt wird noch einmal speziell auf das Sprachkonstrukt der Typkonstruktorklassen eingegangen.
Eine generelle Beschreibung der Sprache Haskell würde an dieser Stelle zu weit führen, hier sei auf \cite{haskell} verwiesen.

%In dieser Arbeit wird mit einer Teilsprache von Haskell gearbeitet, die ähnlich funktioniert wie der Girard-Reynolds-Kalkül,
%erweitert um Fixpunkte, algebraische Datentypen und \textit{seq} \cite{johann}. Zu beachten ist, dass keine formelle
%Semantik für die komplette Programmiersprache Haskell existiert \cite{johann}. \todo{nötig?}

%%% SO ZIEMLICH 1:1 AUS WADLER ÜBERNOMMEN %%%
%Haskell basiert auf dem Hindley/Milner Typsystem, in dem Typen nicht explizit angegeben werden müssen, sondern der allgemeinste
%Typ automatisch anhand der Definition inferiert werden kann \cite{wadler}.
%In dieser Arbeit wird, wie auch in \cite{wadler}, das
%Girard/Reynolds System verwendet, in dem die explizite Angabe von Typen gebundener Funktionsvariablen gefordert ist und
%Typapplikation bei polymorphen Typen explizit angezeigt werden muss \cite{wadler}.
%Da jedes Programm im Hindley/Milner System automatisch in das Giraard/Reynolds System überführt werden kann, entstehen hier
%keine Probleme.

%%%



%Der Fokus
%liegt dabei auf der Erweiterung um Typkonstruktorklassen, weshalb in diesem Abschnitt kurz darauf eingegangen werden soll,
%wie genau eine solche Klasse in Haskell definiert wird. Ansonsten wird davon ausgegangen, dass grundsätzliche Kenntnisse der
%Programmiersprache vorhanden sind, andernfalls sei an dieser Stelle auf \cite{haskell} verwiesen.

Typklassen in Haskell ermöglichen die Umsetzung von Ad-Hoc-Polymorphismus. Man kann beliebige Typklassen selbst definieren,
wobei eine Typklasse immer aus einem Namen, beliebig vielen Funktionssignaturen und gegebenenfalls auch aus vordefinierten
Standardimplementierungen einzelner Funktionen besteht. Haskell transformiert Programme mit Typklassen intern in Programme
ohne dieses Konstrukt, auch Wörterbuchtransformation (engl. ``dictionary translation'') genannt \cite{jones}.

Es folgt ein einfaches Beispiel, das auch in der Prelude von Haskell enthalten ist.

%Typklassen in Haskell setzen Ad-Hoc-Polyphormismus um und können beliebig definiert werden. Eine Typklasse besteht aus
%einem Namen, beliebig vielen Funktionssignaturen und gegebenenfalls aus vordefinierten Implementierungen einzelner
%Funktionen. Es folgt ein einfaches Beispiel, das auch in der Prelude von Haskell enthalten ist \todo{ist es?}.

\begin{minted}{haskell}
class Show a where
   show :: a -> String
\end{minted}

Der Name dieser Beispielklasse ist \texttt{Show}. Man gibt eine Typvariable an, in diesem Fall \texttt{a}, die auch in jeder
Funktionssignatur vorkommen muss. In dieser Beispielklasse wird genau eine Funktionssignatur eingeführt: Die Signatur
\texttt{a -> String} für die Funktion \texttt{show}.

Im weiteren Haskellprogramm können nun für beliebige Datentypen Instanzdeklarationen angegeben werden. Der folgende
Quellcode zeigt ein Beispiel für einen selbstdefinierten Datentyp.

\begin{minted}{haskell}
data Test = Test Int String

instance Show Test where
   show (Test _ s) = "Test " ++ s
\end{minted}

Kommt nun im Programm in einem Ausdruck der Funktionsaufruf \texttt{show} vor, so wird anhand des Parametertypen
entschieden, welche Instanz dieser Klasse verwendet wird. Es kann also für jeden Typen eine komplett eigene Implementierung
angegeben werden.

Hat man eine Typklasse definiert, kann man im Folgenden in beliebigen Typsignaturen einen Kontext angeben, der
bestimmte Typvariablen auf bestimmte Klassen festlegt, wie es das folgende Beispiel zeigt.

\begin{minted}{haskell}
test :: Functor f => f Int -> f Int
\end{minted}

Hier ist \texttt{f} eine freie Typvariable, für die jedoch ein Kontext angegeben ist, der besagt, dass für $f$ nur Instanzen
der Typklasse \texttt{Functor} infrage kommen. Im Gegenzug für diese Einschränkung ist es in der Implementierung möglich,
die Funktionen dieser Klasse zu nutzen, da sichergestellt ist, dass Implementierungen dieser Funktionen
existieren. Die folgende Funktionsdefinition ist also eine mögliche Implementierung der obigen Beispielsignatur.

\begin{minted}{haskell}
test x = fmap (+1) x
\end{minted}

Haskell erkennt, dass \texttt{x} ein Typ sein muss, für den eine \texttt{Functor}-Instanz deklariert ist, weshalb eine
\texttt{fmap}-Implementierung existiert.

Nun ist es ja auch möglich, dass ein selbstdefinierter Datentyp einen Typen als Parameter erwartet, wie das folgende Beispiel
zeigt.

\begin{minted}{haskell}
data Test a = Test a String
\end{minted}

Beim Ausdruck \texttt{Test} handelt es sich in diesem Fall also nicht um einen Typen, sondern eher um einen funktionsähnlichen Ausdruck, der
einen Typen als Parameter erwartet und einen Typen zurückgibt. Man spricht hier auch von \textit{Sorten} (engl. ``kinds''). Haskell
führt für Sorten eine eigene Notation ein. Alle Basistypen wie \texttt{Int}, \texttt{String}, etc. sind von der Sorte *.
Typkonstruktoren, die einen Typen als Parameter erwarten und daraus einen neuen Typen konstruieren, sind von der Sorte
$* \rightarrow *$.
Kompliziertere Sorten wie zum Beispiel $* \rightarrow (* \rightarrow *) \rightarrow *$ sind theoretisch ebenfalls möglich,
werden aber in dieser Arbeit keine Anwendung finden.

Typklassen können auch für Datentypen definiert werden, die Typparameter erwarten. Das folgende Beispiel zeigt die
Definition für die Typklasse \texttt{Functor}, die für einen Typen definiert ist, der wiederum einen Typparameter erwartet.

\begin{minted}{haskell}
class Functor f where
   fmap :: (a -> b) -> f a -> f b
\end{minted}

Hier ist \texttt{f} die Typvariable. Die Signatur für \texttt{fmap} lässt erkennen, dass \texttt{f} auf einen Parameter appliziert
wird, $f$ muss also von der Sorte $* \rightarrow *$ sein. Zu beachten ist hier, dass es keinen Sinn macht (und auch nicht
gestattet ist), dass die Typvariable mit unterschiedlichen Argumentzahlen auftaucht. Ebenso wäre es ungültig,
eine Instanz von \texttt{Functor} zu definieren für einen Datentyp, der keine Typparameter erwartet.

Nachfolgend ist ein Beispiel zu sehen, in dem ein Datentyp namens \texttt{Test} deklariert wird und in einer \texttt{instance}-Deklaration
eine Instanz für die Typklasse \texttt{Functor} beschrieben wird.

\begin{minted}{haskell}
data Test = Test String Int

instance Functor Test where
   fmap = undefined
\end{minted}

Davon abgesehen, dass \texttt{fmap} als undefined deklariert ist (eine sinnvolle Implementierung ist hier ohnehin nicht wirklich
möglich), ergibt diese Deklaration bereits zur Kompilierzeit den folgenden Fehler.

\begin{minted}{text}
    The first argument of `Functor' should have kind `* -> *',
      but `Test' has kind `*'
    In the instance declaration for `Functor Test'
\end{minted}

Haskell meldet also, dass der Datentyp \texttt{Test} von der falschen Sorte ist: Statt der erwarteten Sorte $* \rightarrow *$
wird die Sorte $*$ vorgefunden und es kommt zum Kompilierfehler.

%Wie nutzt man diese Typklassen, nachdem man sie definiert hat? Man kann für beliebige Typvariablen in Signaturen einen Kontext
%angeben, das heißt man schränkt die Typvariablen auf bestimmte Typklassen ein. Zu sehen ist das im folgenden Beispiel.
