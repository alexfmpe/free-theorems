% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

\usepackage{todonotes}
\usepackage{mathrsfs}

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

\usepackage{courier}
\usepackage{amsmath}

\usepackage{listings}
\lstset{
  tabsize=2,
  frame=single,
  basicstyle=\footnotesize\ttfamily
}

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{amssymb}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\title{Anfang}
\author{Thomas Rossow}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\section{Einleitung}

An der Typsignatur einer Funktion lassen sich in funktionalen Sprachen bereits viele Eigenschaften ablesen, ohne dass man dazu die
tatsächliche Implementierung der entsprechenden Funktion kennen muss \cite{wadler}.

usw.

\section{Grundlagen}

In diesem Abschnitt sollen einige Grundlagen eingeführt werden, die in den folgenden Kapiteln von Bedeutung sind. Zunächst werden
einige Definitionen und Notationen bezüglich Relationen angegeben. Der nächste Abschnitt beschäftigt sich dann mit der
grundsätzlichen Idee hinter den freien Theoremen, während sich der darauf folgende Abschnitt mit den Besonderheiten beschäftigt,
die Typkonstruktorklassen mit sich bringen.

\subsection{Relationen}

Eventuell Definitionen, Schreibweisen etc. einführen.

usw.

\subsection{Freie Theoreme}
\label{sec:freie-theoreme}

% % % neue version % % %

Die funktionale Programmiersprache Haskell bietet ein umfassendes Typsystem, das unter anderem parametrischen Polymorphismus
unterstützt. Nicht nur verringert ein solches Typsystem die Fehleranfälligkeit von produziertem Code, es vereinfacht es auch,
Rückschlüsse auf die Funktionsweise zu ziehen und mathematische Beweise zu führen.
Zudem ermöglicht es, bestimmte Theoreme für beliebige Typen herzuleiten, ohne überhaupt die konkrete Implementierung
in Betracht ziehen zu müssen. Dieses sind die sogenannten ``freien Theoreme'', weil man sie gewissermaßen ``geschenkt''
bekommt. Wie genau man diese Theoreme herleitet, soll in diesem Abschnitt genauer erläutert werden.

\subsubsection{Grundsätzliches Vorgehen}

Zunächst bietet es sich an, die Vorgehensweise an einem konkreten Beispiel vorzuführen. Wir betrachten die folgende Haskell-Funktion:

\begin{align}
f :: [a] \rightarrow [a]
\end{align}

Gegeben ist also eine Funktion f, die von einer Liste auf eine Liste abbildet. Das Besondere an dieser Funktion ist, dass sie
nicht für einen konkreten definiert ist, sondern für einen beliebigen Typen, dargestellt durch die Typvariable a. Es handelt sich
also um eine polymorphe Funktion.
Bei Polymorphismus ist zwischen Ad-Hoc Polymorphismus und parametrischem Polymorphismus zu unterscheiden. Hier handelt es sich um parametrischen Polymorphismus, was bedeutet, dass die Funktion für sämtliche Typen ähnlich arbeitet. Anders beim Ad-Hoc-Polymorphismus: Hier kann für jeden Typen eine ganz eigene Implementierung existieren, was es unmöglich macht, allgemeine
Aussagen zu treffen.
Die Funktion ist also für jeden beliebigen Typen a definiert. Das schränkt die Implementierung aber arg ein. Man muss sich an dieser Stelle Fragen: Wie kann die Funktion die Ergebnisliste erzeugen? Sie kennt den konkreten Typen nicht, sie kann lediglich auf die Elemente der Eingabeliste zurückgreifen. Die einzige Möglichkeit, die Liste zu ändern, besteht für die Funktion in einer Neusortierung der Liste.

Doch auch für eine Neusortierung der Liste hat die Funktion wenig Anhaltspunkte. Sie kennt die Länge der Liste, doch ohne Kenntnis des Typen kann sie keine weiteren Aussagen über den Inhalt der einzelnen Listenelemente treffen (und da die Klasse Eq nicht
gegeben ist, nicht mal über deren Gleichheit). Sie wird also für zwei Listen gleicher Länge $l$ und $l'$ exakt das Gleiche tun.
Die Haskell-Funktion \texttt{$map :: (a \rightarrow b) \rightarrow [a] \rightarrow [b]$} wendet eine Funktion auf jedes Element einer Liste an und gibt die resultierende Liste zurück. Oder man interpretiert die Funktion so, dass sie eine Funktion in den Listen-Kontext ``liftet'' und
eine Funktion zurückgibt, die sich auf Listen anwenden lässt. Betrachten wir nun eine beliebige Funktion $g :: a \rightarrow a$. Es lassen sich jetzt Aussagen über $map g$, angewandt auf Listen, treffen. Zum einen wird jede Liste, auf die man $map g$ anwendet, die gleiche Länge haben wie vorher - das liegt einfach in der Natur von $map$.
Darüber hinaus müssen jeweils zwei Elemente, die an der gleichen Position stehen, auf die gleiche Weise entstanden sein, nämlich
durch Anwenden von $g$ auf das entsprechende Listenelement.
Es ist nun logisch, dass es egal ist, ob man zuerst die Funktion f auf eine Liste anwendet und dann die Funktion g auf die
resultierende Liste mappt, oder ob man in umgekehrter Reihenfolge vorgeht. In Zeichen:

\begin{align}
f (map g l) = map g (f l)
\end{align}

Diese Aussage ist ein Theorem, das für beliebige Funktionen g und beliebige Listen l gilt. Doch nicht nur das: Wir haben für
die Herleitung kein Wissen über die konkrete Implementierung der Funktion f, alles was bekannt war, war die Typsignatur.
Das Theorem gilt also insbesondere für alle Funktionen mit der Typsignatur $[a] \rightarrow [a]$. Da man dieses Theorem
aus der Typsignatur ``geschenkt'' bekommt, wird es auch ``freies Theorem'' genannt.
Natürlich war die vorangegangene Herleitung sehr unkonkret und nicht wirklich mathematischer Natur. Daher soll im Folgenden
erklärt werden, wie man freie Theoreme im Allgemeinen und vor allem mathematisch korrekt herleitet.

Der Schlüssel zur Herleitung von freien Theoremen liegt in der Betrachtung von Typen. Ein intuitiver Ansatz, Typen zu verstehen,
ist die Interpretation von einem Typen als Menge. So würde man den Typen \texttt{Bool} beispielsweise als Menge $\mathbb{B}$
der booleschen Werte auffassen, mit $\mathbb{B} = \{ tt, ff \}$, der Typ \texttt{Int} wäre die Menge der ganzen Zahlen
$\mathbb{Z}$ usw. Komplexere Typen ergeben sich dann durch Zusammensetzung aus einzelnen Basistypen, beispielsweise
würde man den Typen \texttt{$Int \rightarrow Int$} auffassen als die Menge $(\mathbb{Z} \rightarrow \mathbb{Z})$ aller Funktionen von den ganzen Zahlen in die ganzen Zahlen.

Für die Herleitung von freien Theoremen ist diese Repräsentation nicht ganz ausreichend, da sie spätestens bei polymorphen
Typen auf beweistechnische Probleme stößt. Daher greift man auf eine etwas andere Repräsentation zurück: Man betrachtet
Typen als Relationen. Eine Relation $\mathcal{R}$ auf zwei Mengen $S$ und $T$, auch geschrieben $\mathcal{R} : S \Leftrightarrow T$, ist eine Menge von Paaren $\mathcal{R} \subset S \times T$. Zwei elemente $s \in S$, $t \in T$ sind verwandt bezüglich
$\mathcal{R}$, wenn $(s, t) \in \mathcal{R}$.

Man kann zu einem Typen nun systematisch eine Relation konstruieren, die diesen Typen repräsentiert. Dazu geht man
folgendermaßen vor:

\begin{itemize}
\item Zu jedem Basistypen $T$ (Int, Bool, etc.) ist die zugehörige Relation die Identitätsrelation $\mathcal{R} = \{ (x, x) | x \in T\}$.
\item Sind $\mathcal{R} : R_1 \Leftrightarrow R_2$ und $\mathcal{S} : S_1 \Leftrightarrow S_2$ Typrelationen, so ist $\mathcal{R} \rightarrow \mathcal{S} = \{ (f, g) | f \in (R_1 \rightarrow R_2), g \in (S_1 \rightarrow S_2), \forall x \in R_1, y \in R_2: (f x, g y) \in \mathcal{S} \}$ die zugehörige Funktionstyprelation.
\item Ist $\mathcal{F}(\mathcal{X})$ eine Typrelation, die von einer Typrelation $\mathcal{X}$ abhängt, dann definiert man
$\forall \mathcal{X} . \mathcal{F}(\mathcal{X}) = \{ (x, y) | \forall A_1, A_2 \in Typen, \mathcal{A} : A_1 \Leftrightarrow A_2: 
(x_{A_1}, y_{A_2}) \in \mathcal{F}(\mathcal{A}) \}$. Hierbei sind $x$ und $y$ polymorphe Elemente, die durch $x_{A_1}$ und $y_{A_2}$
auf einen bestimmten Typ instanziiert werden.
\end{itemize}

Zudem lassen sich bestimmte Typkonstruktoren, wie beispielsweise der Listenkonstruktor $[a]$, durch Lifting der betreffenden
Relation umsetzen. Man kann beispielsweise für Typrelation $\mathcal{R} : T_1 \Leftrightarrow T_2$ rekursiv definieren:

\begin{align}
[\mathcal{R}] = \{ ([], []) \} \cup \{ (a : as, b : bs) | (a, b) \in \mathcal{R}, (as, bs) \in [\mathcal{R}] \}
\end{align}

Andere Standardtypkonstruktoren kann man auf ähnliche Weise definieren. Nun haben wir die Mittel, zu jeder vorhandenen
Typsignatur eine Relation zu konstruieren. Eine entscheidende Erkenntnis von \cite{wadler}, aufbauend auf
\cite{reynolds}, ist nun folgende: Ist t ein geschlossener Term von Typ T und $\mathcal{T}$ die zugehörige konstruierte
Typrelation, dann gilt $(t, t) \in \mathcal{T}$ (\textit{Parametricity}).

Damit ist alles gegeben, was man zur Herleitung des freine Theorems benötigt. Wir untersuchen wieder das Beispiel
$f :: [a] \rightarrow [a]$. Durch Parametrizität ist gegeben:

\begin{align}
(f, f) \in \forall \mathcal{R} . [\mathcal{R}] \rightarrow [\mathcal{R}]
\end{align}

Dabei ist zu bemerken, dass in Haskellsyntax typischerweise die Allquantifizierung über die Typvariable weggelassen wird.
Implizit ist $[a] \rightarrow [a]$ aber gleichbedeutend mit $\forall a . [a] \rightarrow [a]$.
Wir können nun Schritt für Schritt die Definitionen der einzelnen Relationskonstruktionen anwenden, wodurch die Aussage
entfaltet wird:

\begin{align*}
&\forall A_1, A_2 \in Typen, \mathcal{A} : A_1 \Leftrightarrow A_2: \\
&(f_{A_1}, f_{A_2}) \in [\mathcal{A}] \rightarrow [\mathcal{A}] \\
& \\
\Leftrightarrow &
\forall A_1, A_2 \in Typen, \mathcal{A} : A_1 \Leftrightarrow A_2: \\
& \forall (l, l') \in [\mathcal{A}]: \\
&(f_{A_1} l, f_{A_2} l') \in [\mathcal{A}] \\
& \\
\Leftrightarrow &
\forall A_1, A_2 \in Typen, \mathcal{A} : A_1 \Leftrightarrow A_2: \\
& \forall (l, l') \in lift_{[]}(\mathcal{A}): \\
& (f_{A_1} l, f_{A_2} l') \in lift_{[]}(\mathcal{A}) \\
\end{align*}

An diesem Punkt haben wir eine Aussage über beliebige Typrelationen $\mathcal{A}$, anschaulicher wäre aber eine Aussage
über beliebige Funktionen. Da man Funtktionen als Spezialfall von Relationen betrachten kann, können wir die Aussage
spezifizieren für den Fall, dass es sich bei $\mathcal{A}$ um eine Funktion handelt.
Eine Funktion $f : S \rightarrow T$ kann man auch betrachten als Relation $\{ (x, f x) | x \in S \}$. Anders gesagt: Ist
$\mathcal{F} : T_1 \Leftrightarrow T_2$ eine Relation zu einer Funktion f, dann gilt für alle $(x, y) \in \mathcal{F}: f x = y$.

Schränken wir also unsere Aussage auf Funktionen ein, können wir über alle Funktionen $g : A_1 \rightarrow A_2$ quantifizieren.
Wir wissen, dass für alle Parameter $l, l' \in lift_{[]}(\mathcal{A})$ die Aussage $(f_{A_1} l, f_{A_2} l') \in lift_{[]}(\mathcal{A})$
gilt. Als Funktion geschrieben heißt das, es gilt:

\begin{align}
lift_{[]}(g) (f_{A_1} l) = f_{A_2} l'
\end{align}

Das Lifting von Funktionen in den Listenkontext ist ganz einfach das Mapping dieser Funktion auf Listen, sprich: die Haskell-Funktion
$map$, angewandt auf die entsprechende Funktion:

\begin{align}
map g (f_{A_1} l) = f_{A_2} l'
\end{align}

Da $(l, l') \in [A]$, können wir $l'$ auch anders ausdrücken als $map g l = l'$. Man erhält also:

\begin{align}
map g (f_{A_1} l) = f_{A_2} (map g l)
\end{align}

Und man erkennt: Es handelt sich um die gleiche Aussage, die wir vorher intuitiv konstruiert haben. Jetzt haben wir bewiesen,
dass sie gültig ist, da Parametrizität gilt. Doch das ist nicht alles, wir können ein entsprechendes Theorem für jede beliebige
Typsignatur herleiten.

\subsubsection{Typkonstruktorklassen und -variablen}

Eine Sache, die bisher nur kurz angerissen wurde, ist die Interpretation von Typkonstruktoren. Für den Listentypkonstruktor
wurde eine Formel gegeben, mit der eine Relation in den Listenkontext geliftet wird. Ähnlich kann man auch bei anderen Typen
vorgehen, beispielsweise Maybe.

Was aber völlig ignoriert wurde ist die Tatsache, dass man in Haskell auch über Typvariablen allquantifizieren kann, die ihrerseits
nicht Platzhalter für speziellele Typen, sondern nur für Typkonstruktoren sind. Hier ein Beispiel:

\begin{align*}
fmap :: Functor f \Rightarrow (a \rightarrow b) \rightarrow f a \rightarrow f b
\end{align*}

Es wird angegeben, dass $f$ eine Variable der Typklasse Funktor ist. Functor ist vom \textit{kind} $* \rightarrow *$, das heißt es
ist ein Typ höherer Ordnung, der einen Typ auf einen neuen Typ abbildet. Daher kann $f$ in der Typsignatur in $f a$ und $f b$ auf
Parameter angewandt werden.
Zwei Dinge müssen zum bisherigen Ansatz hinzugefügt werden: Allquantifizierung über Typkonstruktorvariablen muss separat betrachtet werden, und Klasseneinschränkungen müssen beachtet werden, im obigen Beispiel $Functor f$.

Die Allquantifizierung über Typkonstruktorvariablen funktioniert an sich ähnlich wie die Allquantifizierung über gewöhnliche
Typvariablen. Statt beliebigen Relationen über beliebig gewählten Typen interpretiert man freie Typkonstruktorvariablen als
Funktionen über Relationen mit beliebig gewählten Typkonstruktoren \cite{voigtlander}.

Dazu kommt noch die Beschränkung auf bestimmte Klassen. In einer Klassendefinition legt man Typparameter sowie
Klassenfunktionen fest. Als Beispiel bietet sich die Klassendefinition, hier beschränkt auf die interessante Funktion
$fmap$:

\begin{lstlisting}[language=Haskell]
class Functor f where
  fmap :: (a -> b) -> f a -> f b
\end{lstlisting}

Wie man sieht, hat die Klasse Functor einen Typparameter $f$ und definiert die Typsignatur zu $fmap$. Stößt man jetzt in
einer Typsignatur auf eine Klassenbeschränkung wie $Functor f$ (ohne die Typkonstruktorvariablen wenig Sinn machen),
muss man die Allquantifizierung über Typkonstruktoren weiter einschränken.

Sei $\mathcal{F}(\mathcal{X})$ wieder eine Typrelation, die von Typrelation $\mathcal{X}$ abhängt, und sei C eine Typklasse. Wir definieren Allquantifizierung über Typkonstruktorvariablen als:

\begin{align*}
\forall \mathcal{K} . \mathcal{F}(\mathcal{X}) = \{ 
(x_{k1}, x'_{k2}) | k_1, k_2 \in \text{Typkonstruktoren für C, die C einhalten},\\
\mathcal{A} : k_1 \Leftrightarrow k_2, (x, x') \in \mathcal{F}(\mathcal{A})
\}
\end{align*}

Was ist nun mit Typkonstruktoren gemeint, die die Klasse C einhalten? Es werden nur jene Typkonstruktoren in Betracht gezogen,
für die jede Klassenfunktion bezüglich ihrer Typrelation mit sich selbst verwandt ist. Für unser Beispiel bedeutet das, es werden nur
Funktionen $\mathcal{F} : k_1 \Leftrightarrow k_2$ betrachtet, für die gilt:

\begin{align*}
(fmap_{k_1}, fmap_{k_2}) \in \forall \mathcal{R} . (\mathcal{R} \rightarrow \mathcal{S}) \rightarrow \mathcal{F} \mathcal{R}
\rightarrow \mathcal{F} \mathcal{S}
\end{align*}

Die Anwendung von Typkonstruktorfunktionen auf Typrelationen ist nun nichts anderes als wiederum ein Lifting dieser
Relation - mit dem Unterschied, dass wir erstmal keine genauen Aussagen über dieses Lifting treffen können.
Eine Frage, die sich nun stellt, ist: Inwiefern kann man dann überhaupt mit diesen Relationsfunktionen arbeiten? An sich ist ja nur
bekannt, dass sie Typrelationen auf andere Typrelationen abbilden. Mit der Klassenbeschränkung ist aber zumindest ein
Anhaltspunkt gegeben. So kann man im Fall der $Functor$ Klasse beispielsweise davon ausgehen, dass es in irgendeiner
Art und Weise möglich sein muss, den ``Inhalt'' des Functors zu manipulieren - eine Art ``natürliches'' $map$ 
todo{Quelle? Beweis?}, das im folgenden $map_F$ genannt wird.

In Haskell gibt es einige Typklassen, für die spezielle Gesetze formuliert werden. Diese Gesetze sind nicht in Haskell
verankert, und theoretisch hindert einen nichts daran, diese Gesetze zu missachten. Ein prominentes Beispiel ist die
Monadenklasse, die die Funktionen $return$ und $(>>=)$ angibt. Für jede Monadeninstanz sollte (!) gelten:

\begin{lstlisting}
return a >>= k  =  k a
m >>= return  =  m
m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
\end{lstlisting}

Auch für die Functor-Klasse sind solche Gesetze definiert:

\begin{lstlisting}
fmap id      = id
fmap (p . q) = (fmap p) . (fmap q)
\end{lstlisting}

An diesen Gesetzen ist interessant, dass tatsächlich nur das erste Gesetz gelten muss - das zweite folgt dann automatisch
aus dem freien Theorem von $fmap$, wird uns also abermals ``geschenkt''. Um das zu zeigen, folgen wir wieder der typischen Vorgehensweise:

\begin{align*}
\end{align*}

% HIER WEITER - Zettel ``Freies Theorem von fmap''

\newpage

% % % ende neue version % % %

%Typischerweise würde man, ganz intuitiv, den Typ eines Ausdrucks als Menge auffassen; der Ausdruck selbst ist also ein
%Element dieser Menge. Betrachtet man beispielsweise den Typ \texttt{Integer},
%wäre dementsprechend die zugehörige Menge die Menge der ganzen Zahlen $\mathbb{Z}$ \cite{bla}. Der Typ
%\texttt{Integer -> Integer} wäre die Menge aller Funktionen $f : \mathbb{Z} \rightarrow \mathbb{Z}$ usw.
%Um freie Theoreme (insbesondere automatisch) zu generieren, bedient man sich einer anderen Darstellung für Typen: Man fasst
%sie als Relationen auf. Die primitiven Typen werden aufgefasst als die Identitätsrelationen auf der jeweiligen repräsentierten Menge. Betrachtet man beispielsweise den Typ \texttt{Boolean}, betrachtet man die Relation $\{ (a, a) | a \in \mathbb{B} \}$, also
%$id_{\mathbb{B}} = \{({tt}, {tt}), ({ff}, {ff})\}$.
%
%Auf diesen Basistypen aufbauend kann man nun sämtliche Typen darstellen, indem man aus den Relationen der einzelnen Typen
%induktiv neue Relationen bildet, die dann Funktionen, Allquantifizierung usw. darstellen. Im Folgenden werden die einzelnen
%Konstruktionen beschrieben. \cite{voigtlander}
%
%\begin{align}
%R \rightarrow S & := \{ (f, g) | \forall (a, b) \in R. (f a, f g) \in S \} \\
%\forall R . F R & := \{ (u, v) | \forall t_1, t_2, R : t1 \leftrightarrow t2 . (u_{t_1}, v_{t_2}) \in F R\}
%\end{align}
%
%In der ersten Zeile ist zu sehen, wie Relationen gebildet werden, die Funktionen von R nach S darstellen (wobei R und S in diesem
%Fall natürlich die Relationen sind, die Ursprungs- . Die zweite Definition zeigt, wie Allquantifizierung über eine Typvariable ($R$) als Relation beschrieben wird. In dieser zweiten Zeile liegt auch der Trick, der das Ermitteln von Theoremen erlaubt.
%
%\todo{ziemlich ungenau}
%
%Es gilt nun für jeden Ausdruck $t$, dessen Typ durch die wie oben konstruierte Relation R dargestellt wird,  die Aussage:
%
%\begin{align*}
%   (t, t) \in R
%\end{align*}
%
%Und hier setzt das Vorgehen der freien Theoreme an: Da man weiß, dass der entsprechende Ausdruck in der Relation
%vorkommt, kann man Schritt für Schritt die Definitionen der einzelnen Relationskonstruktionen wieder entfalten.
%
%\todo{Verweis auf Beweis}
%
%usw.
%
%Das Vorgehen soll im Folgenden an einem Beispiel verdeutlicht werden. Wir betrachten die Funktionssignatur \texttt{f :: a -> a}.
%
%\subsection{Erweiterung um Typkonstruktorklassen}
%
%Im vorangegangenen Abschnitt wurde bereits erwähnt, wie mit vorgegebenen Typkonstruktoren wie z.B. dem Listenkonstruktor
%umgegangen wird. \todo{wurde noch nicht}
%Nun ist es aber möglich, dass der Typkonstruktor kein fester Wert, sondern selbst eine Variable ist. Hier wird ähnlich vorgegangen wie bei
%Allquantifizierungen von Typvariablen: Während letztere als Relationen zwischen beliebig gewählten geschlossenen Typen interpretiert werden, sind Typkonstruktorvariablen Funktionen auf solchen Relationen, die an beliebig gewählte Typkonstruktoren
%gebunden sind.
%\todo {Quelle}
%
%usw.

\section{Die Bibliothek free-theorems}

In \cite{freetheorems} wird eine Implementierung vorgestellt, die die automatisierte Generierung von freien Theoremen aus
Haskell-Code ermöglicht und die Grundlage darstellt, auf die die vorliegende Arbeit aufbaut.
Sie erlaubt das Parsen von Haskell-Code, das Herausfiltern der entsprechenden Definitionen und deren relationale
Interpretation, um schließlich die freien Theoreme zu erzeugen.
Beigefügte Pretty printing Funktionen für Haskell-Syntax und Theoreme vereinfachen schließlich deren Darstellung.

\subsection{Language-Subsets}

free-theorems definiert verschiedene Untermengen der Programmiersprache Haskell, zu denen sich unterschiedlich komplexe
Theoreme generieren lassen. Ein Faktor, der nämlich Probleme bereiten kann, ist der Fixpunktoperator - und damit auch rekursive
Funktionenen im Allgemeinen.
Die Bilbiothek definiert drei Untermengen:

\begin{itemize}
   \item BasicSubset
   \item SubsetWithFix
   \item SubsetWithSeq
\end{itemize}

Die erste Untermenge, BasicSubset, entspricht dem Girard-Reynoldschen Lambda-Kalkül \cite{bla}, erweitert um Datentypen und
Typklassen \cite{freetheorems}. Insbesondere sind aber keine undefinierten Werte erlaubt, die zum Beispiel durch Nichtterminierung,
Division durch Null oder Pattern Matching Fehler auftreten.
Das ändert sich in SubsetWithFix. Hier ist zusätzlich der Fixpunktoperator \textit{fix} verfügbar, und es müssen folglich undefinierte
Werte erlaubt werden. Was noch fehlt, ist die \textit{seq}-Funktion sowie Striktheits-Flags. Letztere können bei selbstdefinierten
Datentypen an die einzelnen Untertypen \todo{Richtige Bezeichnung für einzelne "Parameter" eines Datentyps?} annotiert werden,
um eine strikte Auswertung zu erzwingen.
Die Untermenge SubsetWithSeq ermöglicht schließlich die zuletzt genannten Aspekte: Es wird Striktheit durch \textit{seq}
eingeführt, dadurch sind dann auch Striktheitsannotationen in Datentypen möglich.

Es wird noch eine weitere Unterscheidung eingeführt: Zu SubsetWithFix und SubsetWithSeq kann noch unterschieden werden,
ob Gleichungs- oder Ungleichungsresultate gewünscht sind. \todo{equational and inequational results - bessere Übersetzung?}
Daraus ergeben sich insgesamt fünf Varianten, für die \cite{freetheorems} die folgende Schreibweise einführt, wobei $M$ die Menge
der verfügbaren \textit{Modelle} ist:

\begin{align}
M = \{(basic, =), (fix, =), (fix, \sqsubseteq), (seq, =), (seq, \sqsubseteq)\}
\end{align}

\subsection{Aufbau}

\cite{freetheorems} gliedert die Bibliothek in drei grundsätzliche Teile: \todo{S. 53 Arbeit} Frontend, Core und Pretty printer. \todo{Abbildung zur Veranschaulichung?}
Zunächst werden im Frontend Parser bereitgestellt, um den Haskellcode aus einer Zeichenkette in eine passende Syntaxbaumstruktur umzuwandeln. Mithilfe einer check-Funktion
wird diese Datenstruktur auf Gültigkeit überprüft, insbesondere in Bezug auf spezielle Anforderungen, die an die Definitionen gestellt wird, um Theoreme zu generieren.

\texttt{interpret} ist dann schließlich die Funktion, die eine Signatur in Bezug auf die anderen Deklarationen in eine Zwischendarstellung \texttt{Intermediate} überträgt. Die
Funktion \texttt{asTheorem} entfaltet diese Darstellung \todo{``entfaltet''?} schließlich und überträgt sie in den Datentyp \texttt{Theorem}.

\subsection{Parser}

Neben dem Haskell 98 Parser, der keine \todo{Keine?} Spracherweiterungen zulässt, ist auch der Hsx Compiler gegeben, der die
komplette Sprache mitsamt Spracherweiterungen umsetzt. Hier ist anzumerken, dass das Paket free-theorems in seiner aktuellen Form
nicht mit dem aktuellen Haskell-Compiler kompatibel war und einige Anpassungen gemacht werden mussten. \todo{Evtl im Anhang Näheres?}
Intern nutzt free-theorems hier die Pakete \texttt{Language.Haskell.Parser} bzw. \texttt{Language.Haskell.Exts.Parser}, die an sich bereits voll funktionstüchtige Parser liefern.

Allerdings ist der komplette Sprachumfang sehr komplex und ein Arbeiten mit den Datenstrukturen, die von diesen genutzten Parsern generiert werden,
wird unnötig erschwert. Aus diesem Grund transformiert free-theorems diese Datenstruktur in eine eigene, vereinfachte Struktur namens BasicSyntax. In dieser Struktur
werden lediglich Typsignaturen festgehalten, Implementierungen werden vollkommen ignoriert, da sie für die Theoremgenerierung keine Rolle spielen.

\subsubsection{BasicSyntax}

Es soll hier zunächst an einigen Beispielen verdeutlicht werden, wie die BasicSyntax-Struktur definiert ist.

\lstinputlisting[language=Haskell]{ast.hs}

Listing \ref{lst:ast} zeigt die Datenstruktur am Beispiel der in der ersten Zeile angegebenen Definition. Die \texttt{parse}-Funktion des Parser-Moduls gibt eine Liste von Definitionen zurück, in diesem Beispiel nur ein Element mit dem Konstruktor \texttt{TypeSig}.

Natürlich ist man hauptsächlich an den Funktionssignaturen interessiert, da man aus diesen die Theoreme ableitet. Aber natürlich können diese Signaturen ihrerseits wiederum 
selbst definierte Datentypen oder auch Klasseneinschränkungen enthalten. Man kommt also nicht umhin, auch diese mit einzubeziehen und ebenfalls in der BasicSyntax vorzusehen.
Das Beispiel in Listing \ref{lst:ast-data} zeigt eine data-Deklaration.

\lstinputlisting[language=Haskell]{ast2.hs}

\subsection{check}
\label{sec:check}

Im zweiten Schritt wird die \texttt{check}-Funktion benutzt, um alle Deklarationen auf Gültigkeit zu überprüfen und die Liste der Deklaration zu filtern. Ungültige Deklarationen
werden unter Angabe einer Fehlermeldung aus der Liste entfernt \cite{freetheorems}.

Es ist zwar davon auszugehen, dass die Syntax des Programmes korrekt ist, da ansonsten der Haskell-Parser bereits im ersten Schritt einen Fehler gemeldet hätte, dennoch ist
dieser zweite Schritt nötig, um auch korrekte Semantik voraussetzen zu können \todo{wahrscheinlich falsch ausgedrückt} (da andernfalls auch für fehlerhafte Programme Theoreme generiert würden, was keinen Sinn macht).

Die check-Funktion untergliedert sich in lokale und globale Checks, wobei die lokalen Checks pro Definition durchgeführt werden, die globalen Checks beziehen sich auf die Gesamtheit aller Definitionen. Beispielsweise wird lokal überprüft, ob bei Deklarationen die freien Variablen auf der rechten Seite auf der linken Seite der Defintion deklariert sind, es wird sichergestellt
dass auf der linken Seite alle Variablennamen verschieden sind, primitive Datentypen nicht deklariert werden usw.

Unter die globalen Checks fällt z.B., dass zu einem Funktionsnamen nicht mehrere Deklarationen existieren, dass alle Typkonstruktoren die korrekte Anzahl an Parametern haben oder auch dass keine Kreise in der Typklassenhierarchie existieren \cite{freetheorems}.

Am Ende schließt \texttt{check} noch alle Typausdrücke, dh. bei frei vorkommenden Typvariablen werden entsprechende Typabstraktionen um den Ausdruck geschlossen. Das ist wichtig, da in der weiteren Implementierung davon ausgegangen wird, dass alle Typausdrücke geschlossen sind und entsprechende Typabstraktionen zu jeder implizit allquantifizierten Variable vorhanden sind.

\subsection{interpret}

Tatsächlich macht die \texttt{interpret}-Funktion nichts, was nicht schon bekannt ist \todo{Das heißt, wenn ich es denn schon geschrieben hätte}: Sie überführt die Funktionssignatur in eine
Relationsdarstellung, wobei sie Typvariablen neu generierte Relationsvariablen zuordnet. Um es mit der Aufteilung von \cite{freetheorems} auszudrücken, stellt sie den Übergang des Frontends zum Core dar, wo der interessante Arbeitsschritt ausgeführt wird.

Der Datentyp, der hier verwendet wird, heißt Immediate. Dieser Datentyp ist letztlich nur ein Container für eine Relation mit
dem repräsentierten Typausdruck, zusätzlichen (unendlichen) Listen von freien Variablennamen und sonstigen Zusatzinformationen.

\subsubsection{Relation}

Für die Darstellung als Relationen definiert free-theorems den Datentyp \texttt{Theorem}, der folgende Konstruktoren hat:

\todo{unvollständig. und evtl unnötig}

\begin{tabular}{| l | l | l |}
\hline
Konstruktor & Parameter & Entsprechung \\
\hline
RelVar & RelationVariable & $\alpha$ \\
FunVar & (Either Term Term) & ? \\
RelBasic & - & R \\
RelLift & TypeConstructor [Relation] & [R], etc. \\
RelFun & Relation Relation & $S \rightarrow T$ \\
RelFunLab & Relation Relation & $S \rightarrow T$ \\
RelAbs & RelationVariable (TypeExpression,  & $\forall R . F R$ \\
& TypeExpression) [Restriction] Relation & \\
FunAbs & ... & \\
\hline
\end{tabular}

Wie man sieht, fehlt noch ein Konstruktor für die neu eingeführte Variante, dass eine Typkonstruktorvariable auf Relationen
angewandt wird. Darauf wird in Abschnitt \ref{sec:erweiterung-typklassen} eingegangen.

\subsection{asTheorem}

Die \texttt{asTheorem}-Funktion stellt eine Datenstruktur des Typs \texttt{Intermediate} als Theorem dar. Tatsächlich passiert hier aber eine ganze Menge mehr als der Name
vermitteln mag. Das schrittweise Entfalten \todo{Würde man wirklich ``entfalten'' sagen?} der Relationen stellt schließlich den entscheidenden Schritt dar, durch den man überhaupt auf
die Theoreme schließen kann.

\todo{Hier eventuell auch ein Beispiel?}

\subsection{Spezialisieren von Relationsvariablen zu Funktionen}

Ist das Theorem generiert, kann man nun die Funktionsrelation spezialisieren, um das Theorem zu vereinfachen. Aus einem
$A : S \leftrightarrow T$ wird also $\forall a : S \rightarrow T$

usw.

\subsection{simplify}

Schließlich bietet free-theorems noch die Möglichkeit, die generierten Theoreme zu vereinfachen, indem nach einigen typischen
Mustern gesucht wird, beispielsweise: Entfernen aller unbenutzten allquantifizierten Variablen, $\forall v. f v == g v \rightarrow f == g$ usw.

\section{Erweiterung um Typklassen und -konstruktoren}
\label{sec:erweiterung-typklassen}

In diesem Abschnitt soll erläutert werden, welche Änderungen an free-theorems vorgenommen werden müssen, um auch Typklassen und Typkonstruktoren miteinzubeziehen. In
Abschnitt 

usw.

\subsection{Erweiterungen der BasicSyntax}

Da Typvariablenapplikation in \cite{freetheorems} nicht vorgesehen ist, musste ein solches Konstrukt in die BasicSyntax-Struktur eingefügt werden. Hierbei ist zu beachten: Die Applikation
von Standardtypkonstruktoren, beispielsweise \texttt{[a]} für Listen, ist sehr wohl vorgesehen und wird in der BasicSyntax durch \texttt{TypeCon} im Datentyp \texttt{TypeExpression} dargestellt. \todo{Wahrscheinlich viel zu speziell} Diese Standardtypkonstruktoren werden in diesem Zusammenhang aber als Sonderfälle betrachtet \ref{sec:freie-theoreme}, um das System wirklich um eigene Typklassen zu erweitern, muss es auch möglich sein, Typkonstruktorvariablen auf Typen anzuwenden.

Die Erweiterung der BasicSyntax sieht hier so aus, dass ein neuer Konstruktor \texttt{TypeVarApp} zum Datentypen \texttt{TypeExpression} hinzugefügt wird. In Listing \ref{lst:typevarapp} ist ein Beispiel zu sehen.

\lstinputlisting[language=Haskell]{typevarapp.hs}

Abgesehen vom offensichtlichen Problem, dass dieser Konstruktor bei der Theoremgenerierung zu Fehlern beim Pattern Matching oder zumindest zu unerwünschtem Verhalten führt,
ist auch zu beachten, dass die in Abschnitt \ref{sec:check} erwähnte \texttt{check}-Funktion entsprechend angepasst wird.

\subsection{Erweiterung von Relation}

Da eine neue Relationskonstruktion eingeführt wird, muss auch der entsprechende Datentyp angepasst werden.

\section{Zusammenfassung}

\section{Ausblick}

\bibliography{masterarbeit}
\bibliographystyle{plain}

\end{document}
