% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

\usepackage{todonotes}

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

\usepackage{courier}
\usepackage{amsmath}

\usepackage{listings}
\lstset{
  tabsize=2,
  frame=single,
  basicstyle=\footnotesize\ttfamily
}

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{amssymb}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\title{Anfang}
\author{Thomas Rossow}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\section{Einleitung}

An der Typsignatur einer Funktion lassen sich in funktionalen Sprachen bereits viele Eigenschaften ablesen, ohne dass man dazu die
tatsächliche Implementierung der entsprechenden Funktion kennen muss \cite{wadler}.

usw.

\section{Grundlagen}

In diesem Abschnitt sollen einige Grundlagen eingeführt werden, die in den folgenden Kapiteln von Bedeutung sind. Zunächst werden
einige Definitionen und Notationen bezüglich Relationen angegeben. Der nächste Abschnitt beschäftigt sich dann mit der
grundsätzlichen Idee hinter den freien Theoremen, während sich der darauf folgende Abschnitt mit den Besonderheiten beschäftigt,
die Typkonstruktorklassen mit sich bringen.

\subsection{Relationen}

Eventuell Definitionen, Schreibweisen etc. einführen.

usw.

\subsection{Freie Theoreme}
\label{sec:freie-theoreme}

Typischerweise würde man, ganz intuitiv, den Typ eines Ausdrucks als Menge auffassen; der Ausdruck selbst ist also ein
Element dieser Menge. Betrachtet man beispielsweise den Typ \texttt{Integer},
wäre dementsprechend die zugehörige Menge die Menge der ganzen Zahlen $\mathbb{Z}$ \cite{bla}. Der Typ
\texttt{Integer -> Integer} wäre die Menge aller Funktionen $f : \mathbb{Z} \rightarrow \mathbb{Z}$ usw.
Um freie Theoreme (insbesondere automatisch) zu generieren, bedient man sich einer anderen Darstellung für Typen: Man fasst
sie als Relationen auf. Die primitiven Typen werden aufgefasst als die Identitätsrelationen auf der jeweiligen repräsentierten Menge. Betrachtet man beispielsweise den Typ \texttt{Boolean}, betrachtet man die Relation $\{ (a, a) | a \in \mathbb{B} \}$, also
$id_{\mathbb{B}} = \{({tt}, {tt}), ({ff}, {ff})\}$.

Auf diesen Basistypen aufbauend kann man nun sämtliche Typen darstellen, indem man aus den Relationen der einzelnen Typen
induktiv neue Relationen bildet, die dann Funktionen, Allquantifizierung usw. darstellen. Im Folgenden werden die einzelnen
Konstruktionen beschrieben. \cite{voigtlander}

\begin{align}
R \rightarrow S & := \{ (f, g) | \forall (a, b) \in R. (f a, f g) \in S \} \\
\forall R . F R & := \{ (u, v) | \forall t_1, t_2, R : t1 \leftrightarrow t2 . (u_{t_1}, v_{t_2}) \in F R\}
\end{align}

In der ersten Zeile ist zu sehen, wie Relationen gebildet werden, die Funktionen von R nach S darstellen (wobei R und S in diesem
Fall natürlich die Relationen sind, die Ursprungs- . Die zweite Definition zeigt, wie Allquantifizierung über eine Typvariable ($R$) als Relation beschrieben wird. In dieser zweiten Zeile liegt auch der Trick, der das Ermitteln von Theoremen erlaubt.

\todo{ziemlich ungenau}

Es gilt nun für jeden Ausdruck $t$, dessen Typ durch die wie oben konstruierte Relation R dargestellt wird,  die Aussage:

\begin{align*}
   (t, t) \in R
\end{align*}

Und hier setzt das Vorgehen der freien Theoreme an: Da man weiß, dass der entsprechende Ausdruck in der Relation
vorkommt, kann man Schritt für Schritt die Definitionen der einzelnen Relationskonstruktionen wieder entfalten.

\todo{Verweis auf Beweis}

usw.

Das Vorgehen soll im Folgenden an einem Beispiel verdeutlicht werden. Wir betrachten die Funktionssignatur \texttt{f :: a -> a}.

\subsection{Erweiterung um Typkonstruktorklassen}

Im vorangegangenen Abschnitt wurde bereits erwähnt, wie mit vorgegebenen Typkonstruktoren wie z.B. dem Listenkonstruktor
umgegangen wird. \todo{wurde noch nicht}
Nun ist es aber möglich, dass der Typkonstruktor kein fester Wert, sondern selbst eine Variable ist. Hier wird ähnlich vorgegangen wie bei
Allquantifizierungen von Typvariablen: Während letztere als Relationen zwischen beliebig gewählten geschlossenen Typen interpretiert werden, sind Typkonstruktorvariablen Funktionen auf solchen Relationen, die an beliebig gewählte Typkonstruktoren
gebunden sind.
\todo {Quelle}

usw.

\section{Die Bibliothek free-theorems}

In \cite{freetheorems} wird eine Implementierung vorgestellt, die die automatisierte Generierung von freien Theoremen aus
Haskell-Code ermöglicht und die Grundlage darstellt, auf die die vorliegende Arbeit aufbaut.
Sie erlaubt das Parsen von Haskell-Code, das Herausfiltern der entsprechenden Definitionen und deren relationale
Interpretation, um schließlich die freien Theoreme zu erzeugen.
Beigefügte Pretty printing Funktionen für Haskell-Syntax und Theoreme vereinfachen schließlich deren Darstellung.

\subsection{Language-Subsets}

free-theorems definiert verschiedene Untermengen der Programmiersprache Haskell, zu denen sich unterschiedlich komplexe
Theoreme generieren lassen. Ein Faktor, der nämlich Probleme bereiten kann, ist der Fixpunktoperator - und damit auch rekursive
Funktionenen im Allgemeinen.
Die Bilbiothek definiert drei Untermengen:

\begin{itemize}
   \item BasicSubset
   \item SubsetWithFix
   \item SubsetWithSeq
\end{itemize}

Die erste Untermenge, BasicSubset, entspricht dem Girard-Reynoldschen Lambda-Kalkül \cite{bla}, erweitert um Datentypen und
Typklassen \cite{freetheorems}. Insbesondere sind aber keine undefinierten Werte erlaubt, die zum Beispiel durch Nichtterminierung,
Division durch Null oder Pattern Matching Fehler auftreten.
Das ändert sich in SubsetWithFix. Hier ist zusätzlich der Fixpunktoperator \textit{fix} verfügbar, und es müssen folglich undefinierte
Werte erlaubt werden. Was noch fehlt, ist die \textit{seq}-Funktion sowie Striktheits-Flags. Letztere können bei selbstdefinierten
Datentypen an die einzelnen Untertypen \todo{Richtige Bezeichnung für einzelne "Parameter" eines Datentyps?} annotiert werden,
um eine strikte Auswertung zu erzwingen.
Die Untermenge SubsetWithSeq ermöglicht schließlich die zuletzt genannten Aspekte: Es wird Striktheit durch \textit{seq}
eingeführt, dadurch sind dann auch Striktheitsannotationen in Datentypen möglich.

Es wird noch eine weitere Unterscheidung eingeführt: Zu SubsetWithFix und SubsetWithSeq kann noch unterschieden werden,
ob Gleichungs- oder Ungleichungsresultate gewünscht sind. \todo{equational and inequational results - bessere Übersetzung?}
Daraus ergeben sich insgesamt fünf Varianten, für die \cite{freetheorems} die folgende Schreibweise einführt, wobei $M$ die Menge
der verfügbaren \textit{Modelle} ist:

\begin{align}
M = \{(basic, =), (fix, =), (fix, \sqsubseteq), (seq, =), (seq, \sqsubseteq)\}
\end{align}

\subsection{Aufbau}

\cite{freetheorems} gliedert die Bibliothek in drei grundsätzliche Teile: \todo{S. 53 Arbeit} Frontend, Core und Pretty printer. \todo{Abbildung zur Veranschaulichung?}
Zunächst werden im Frontend Parser bereitgestellt, um den Haskellcode aus einer Zeichenkette in eine passende Syntaxbaumstruktur umzuwandeln. Mithilfe einer check-Funktion
wird diese Datenstruktur auf Gültigkeit überprüft, insbesondere in Bezug auf spezielle Anforderungen, die an die Definitionen gestellt wird, um Theoreme zu generieren.

\texttt{interpret} ist dann schließlich die Funktion, die eine Signatur in Bezug auf die anderen Deklarationen in eine Zwischendarstellung \texttt{Intermediate} überträgt. Die
Funktion \texttt{asTheorem} entfaltet diese Darstellung \todo{``entfaltet''?} schließlich und überträgt sie in den Datentyp \texttt{Theorem}.

\subsection{Parser}

Neben dem Haskell 98 Parser, der keine \todo{Keine?} Spracherweiterungen zulässt, ist auch der Hsx Compiler gegeben, der die
komplette Sprache mitsamt Spracherweiterungen umsetzt. Hier ist anzumerken, dass das Paket free-theorems in seiner aktuellen Form
nicht mit dem aktuellen Haskell-Compiler kompatibel war und einige Anpassungen gemacht werden mussten. \todo{Evtl im Anhang Näheres?}
Intern nutzt free-theorems hier die Pakete \texttt{Language.Haskell.Parser} bzw. \texttt{Language.Haskell.Exts.Parser}, die an sich bereits voll funktionstüchtige Parser liefern.

Allerdings ist der komplette Sprachumfang sehr komplex und ein Arbeiten mit den Datenstrukturen, die von diesen genutzten Parsern generiert werden,
wird unnötig erschwert. Aus diesem Grund transformiert free-theorems diese Datenstruktur in eine eigene, vereinfachte Struktur namens BasicSyntax. In dieser Struktur
werden lediglich Typsignaturen festgehalten, Implementierungen werden vollkommen ignoriert, da sie für die Theoremgenerierung keine Rolle spielen.

\subsubsection{BasicSyntax}

Es soll hier zunächst an einigen Beispielen verdeutlicht werden, wie die BasicSyntax-Struktur definiert ist.

\lstinputlisting[language=Haskell]{ast.hs}

Listing \ref{lst:ast} zeigt die Datenstruktur am Beispiel der in der ersten Zeile angegebenen Definition. Die \texttt{parse}-Funktion des Parser-Moduls gibt eine Liste von Definitionen zurück, in diesem Beispiel nur ein Element mit dem Konstruktor \texttt{TypeSig}.

Natürlich ist man hauptsächlich an den Funktionssignaturen interessiert, da man aus diesen die Theoreme ableitet. Aber natürlich können diese Signaturen ihrerseits wiederum 
selbst definierte Datentypen oder auch Klasseneinschränkungen enthalten. Man kommt also nicht umhin, auch diese mit einzubeziehen und ebenfalls in der BasicSyntax vorzusehen.
Das Beispiel in Listing \ref{lst:ast-data} zeigt eine data-Deklaration.

\lstinputlisting[language=Haskell]{ast2.hs}

\subsection{check}
\label{sec:check}

Im zweiten Schritt wird die \texttt{check}-Funktion benutzt, um alle Deklarationen auf Gültigkeit zu überprüfen und die Liste der Deklaration zu filtern. Ungültige Deklarationen
werden unter Angabe einer Fehlermeldung aus der Liste entfernt \cite{freetheorems}.

Es ist zwar davon auszugehen, dass die Syntax des Programmes korrekt ist, da ansonsten der Haskell-Parser bereits im ersten Schritt einen Fehler gemeldet hätte, dennoch ist
dieser zweite Schritt nötig, um auch korrekte Semantik voraussetzen zu können \todo{wahrscheinlich falsch ausgedrückt} (da andernfalls auch für fehlerhafte Programme Theoreme generiert würden, was keinen Sinn macht).

Die check-Funktion untergliedert sich in lokale und globale Checks, wobei die lokalen Checks pro Definition durchgeführt werden, die globalen Checks beziehen sich auf die Gesamtheit aller Definitionen. Beispielsweise wird lokal überprüft, ob bei Deklarationen die freien Variablen auf der rechten Seite auf der linken Seite der Defintion deklariert sind, es wird sichergestellt
dass auf der linken Seite alle Variablennamen verschieden sind, primitive Datentypen nicht deklariert werden usw.

Unter die globalen Checks fällt z.B., dass zu einem Funktionsnamen nicht mehrere Deklarationen existieren, dass alle Typkonstruktoren die korrekte Anzahl an Parametern haben oder auch dass keine Kreise in der Typklassenhierarchie existieren \cite{freetheorems}.

\subsection{interpret}

Tatsächlich macht die \texttt{interpret}-Funktion nichts, was nicht schon bekannt ist \todo{Das heißt, wenn ich es denn schon geschrieben hätte}: Sie überführt die Funktionssignatur in eine
Relationsdarstellung, wobei sie Typvariablen neu generierte Relationsvariablen zuordnet. Um es mit der Aufteilung von \cite{freetheorems} auszudrücken, stellt sie den Übergang des Frontends zum Core dar, wo der interessante Arbeitsschritt ausgeführt wird.

Der Datentyp, der hier verwendet wird, heißt Immediate. Dieser Datentyp ist letztlich nur ein Container für eine Relation mit
dem repräsentierten Typausdruck, zusätzlichen (unendlichen) Listen von freien Variablennamen und sonstigen Zusatzinformationen.

\subsubsection{Relation}

Für die Darstellung als Relationen definiert free-theorems den Datentyp \texttt{Theorem}, der folgende Konstruktoren hat:

\todo{unvollständig. und evtl unnötig}

\begin{tabular}{| l | l | l |}
\hline
Konstruktor & Parameter & Entsprechung \\
\hline
RelVar & RelationVariable & $\alpha$ \\
FunVar & (Either Term Term) & ? \\
RelBasic & - & R \\
RelLift & TypeConstructor [Relation] & [R], etc. \\
RelFun & Relation Relation & $S \rightarrow T$ \\
RelFunLab & Relation Relation & $S \rightarrow T$ \\
RelAbs & RelationVariable (TypeExpression,  & $\forall R . F R$ \\
& TypeExpression) [Restriction] Relation & \\
FunAbs & ... & \\
\hline
\end{tabular}

Wie man sieht, fehlt noch ein Konstruktor für die neu eingeführte Variante, dass eine Typkonstruktorvariable auf Relationen
angewandt wird. Darauf wird in Abschnitt \ref{sec:erweiterung-typklassen} eingegangen.

\subsection{asTheorem}

Die \texttt{asTheorem}-Funktion stellt eine Datenstruktur des Typs \texttt{Intermediate} als Theorem dar. Tatsächlich passiert hier aber eine ganze Menge mehr als der Name
vermitteln mag. Das schrittweise Entfalten \todo{Würde man wirklich ``entfalten'' sagen?} der Relationen stellt schließlich den entscheidenden Schritt dar, durch den man überhaupt auf
die Theoreme schließen kann.

\todo{Hier eventuell auch ein Beispiel?}

\subsection{Spezialisieren von Relationsvariablen zu Funktionen}

Ist das Theorem generiert, kann man nun die Funktionsrelation spezialisieren, um das Theorem zu vereinfachen. Aus einem
$A : S \leftrightarrow T$ wird also $\forall a : S \rightarrow T$

usw.

\subsection{simplify}

Schließlich bietet free-theorems noch die Möglichkeit, die generierten Theoreme zu vereinfachen, indem nach einigen typischen
Mustern gesucht wird, beispielsweise: Entfernen aller unbenutzten allquantifizierten Variablen, $\forall v. f v == g v \rightarrow f == g$ usw.

\section{Erweiterung um Typklassen und -konstruktoren}
\label{sec:erweiterung-typklassen}

In diesem Abschnitt soll erläutert werden, welche Änderungen an free-theorems vorgenommen werden müssen, um auch Typklassen und Typkonstruktoren miteinzubeziehen. In
Abschnitt 

usw.

\subsection{Erweiterungen der BasicSyntax}

Da Typvariablenapplikation in \cite{freetheorems} nicht vorgesehen ist, musste ein solches Konstrukt in die BasicSyntax-Struktur eingefügt werden. Hierbei ist zu beachten: Die Applikation
von Standardtypkonstruktoren, beispielsweise \texttt{[a]} für Listen, ist sehr wohl vorgesehen und wird in der BasicSyntax durch \texttt{TypeCon} im Datentyp \texttt{TypeExpression} dargestellt. \todo{Wahrscheinlich viel zu speziell} Diese Standardtypkonstruktoren werden in diesem Zusammenhang aber als Sonderfälle betrachtet \ref{sec:freie-theoreme}, um das System wirklich um eigene Typklassen zu erweitern, muss es auch möglich sein, Typkonstruktorvariablen auf Typen anzuwenden.

Die Erweiterung der BasicSyntax sieht hier so aus, dass ein neuer Konstruktor \texttt{TypeVarApp} zum Datentypen \texttt{TypeExpression} hinzugefügt wird. In Listing \ref{lst:typevarapp} ist ein Beispiel zu sehen.

\lstinputlisting[language=Haskell]{typevarapp.hs}

Abgesehen vom offensichtlichen Problem, dass dieser Konstruktor bei der Theoremgenerierung zu Fehlern beim Pattern Matching oder zumindest zu unerwünschtem Verhalten führt,
ist auch zu beachten, dass die in Abschnitt \ref{sec:check} erwähnte \texttt{check}-Funktion entsprechend angepasst wird.

\subsection{Erweiterung von Relation}

Da eine neue Relationskonstruktion eingeführt wird, muss auch der entsprechende Datentyp angepasst werden.

\section{Zusammenfassung}

\section{Ausblick}

\bibliography{masterarbeit}
\bibliographystyle{plain}

\end{document}
